[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Packages (2e)",
    "section": "",
    "text": "欢迎！\n欢迎来到由 Hadley Wickham 和 Jennifer Bryan 等撰写的第二版 R Package 的在线版本。 软件包（Packages）是可复用 R 代码的基本单位。 它们包含可复用的 R 函数、描述如何使用这些函数的文档以及示例数据。 在本书中，你将学习如何将你的代码变成别人能够轻松下载和使用的软件包。 刚开始编写软件包可能会让人感觉无从下手。 因此我们从基础的内容开始，逐渐提升我们的开发水平。 你的第一个版本是否完美并不重要，只要下一版本变得更完善就好。\n本网站在 CC BY-NC-ND 4.0 许可下是并将永远是免费的。 如果你想要一本实体书，你可以在 Amazon 上订购。",
    "crumbs": [
      "欢迎！"
    ]
  },
  {
    "objectID": "translator-preface.html",
    "href": "translator-preface.html",
    "title": "翻译与排版说明",
    "section": "",
    "text": "翻译说明\n将英文技术书籍翻译为中文是个痛苦的过程，难以避免地会遇到一些没有公认翻译方式的英文词汇，或者是有公认的中文翻译词汇，但该词过于口语化，或者不能很好地反映英文词汇的意思。这些英文词汇以及它们在书中的对应中文词汇将在下方列出，欢迎大家批评。",
    "crumbs": [
      "翻译与排版说明"
    ]
  },
  {
    "objectID": "translator-preface.html#翻译说明",
    "href": "translator-preface.html#翻译说明",
    "title": "翻译与排版说明",
    "section": "",
    "text": "英文词汇\n中文翻译\n原因\n\n\n\npackage\n软件包，程序包，包\nr packages 是一组用来完成特定任务的程序，作为 R 的补充，符合 Software Package 的定义。“包”作为“软件包”的简称使用，在翻译中可能同时使用“软件包”和“包”两种称呼。\n\n\nconscious uncoupling\n有意识地解耦\n这个词最初用于描述相对友好的离婚1，这里使用“有意识地”而非“相对友好的”以突出该决定是经过慎重考虑和精心设计的。\n\n\nThe Whole Game\n整体流程\n软件包构建的一个 toy example，这里采用意译。\n\n\nThe package within\n软件包中的奥秘，包中奥秘\n直译过来是“软件包的内部”，感觉过于平淡，使用更吸引人的翻译。\n\n\ncompelling\n令人信服的\n\n(intro?) 中 “One compelling reason …” 应该想要表达开发 R 包能带来一个明显的优势，即方便分享自己的代码，这一优势具有强烈的推动力和说服力，让你想要开发 R 包。2\n\n\n\nsection\n章节，段落\n本书中的 section 多用于指代层级低于 “chapter” 的文段，有的是小节，也有的是一个段落。\n\n\nespouse\n宣扬，倡导\n直译为“支持”，从语句通顺的角度翻译为“宣扬”。\n\n\nVignette\n主题文档\n原意是“小插曲”、“短文”、“小品文”等，在 R 中 Vignette 是对整个包或包的某个功能主题进行概括性的介绍，这里突出其内容特性，强调其内容为功能“主题”，不强调其独立性和概括性。\n\n\nShunryu Suzuki\n铃木俊隆\n人名的中文翻译依据是 Wikipedia\n\n\n\ntoy package\n示例软件包\n直译过来是“玩具一般的软件包”，表示其各部分相比于真实软件包来说都较为简单，但包含了真实软件包的必要的部分，用于作为一个实例展示开发流程。\n\n\ncommit history\n提交历史\nGitHub 或 Git 中列出的 commit 历史。\n\n\npane, tab\n窗格，选项卡\n窗格是对应用程序窗口的一个分割，而选项卡是在窗格中展示的，可以切换不同的选项卡，窗格中将会展示对应的内容。\n\n\npull, push\n拉取，推送\nGit 远程仓库操作的常用翻译。\n\n\nbehind-the-scenes files\n临时文件\n直译是“幕后文件”，通常指的是一些程序在运行时自动生成的文件，这些文件通常不需要用户干预或直接操作，而是在程序或工具的运行过程中被使用或调用，并且没有用处后会被程序自动删除，因此翻译为更通俗的“临时文件”。\n\n\nhelper; helper function\n辅助函数\n所谓的“helper”是从函数和包的功能上进行描述的，它多指 devtools 包中的函数，可以辅助使用者进行软件包开发等工作。\n\n\nexpose\n提供\n我并不是很满意这个翻译。expose 是指 devtools 提供了来自构成它的其他软件包的函数，类似于“暴露接口”，但“暴露”一词有偏向被动、被揭示的意思，此处是主动提供。\n\n\nqualified call\n限定调用\n在 R 中是形如 pkg::foo() 的形式，指不附加包而是调用函数时添加限定符 pkg::，指查找路径时将查找范围限定在 pkg 的命名空间中。\n\n\nthe whole game\n整个流程\n这是第二章节的标题，该章节以一个 toy package 为例，展示了开发一个软件包的整个流程。\n\n\ntoy package\n示例软件包\n直译过来是“玩具一般的软件包”，表示其各部分相比于真实软件包来说都较为简单，但包含了真实软件包的必要的部分，用于作为一个实例展示开发流程。\n\n\npublic face\n公开接口\n这里指软件包的用户界面，即用户可以直接使用的函数和数据集。\n\n\nsetup\n配置\n这里主要指软件包开发的环境配置和初始化。\n\n\nhelper (function)\n辅助函数\n所谓的“helper”是从函数和包的功能方面进行描述的，多指 devtools 包中的函数，可以辅助使用者进行软件包开发等工作。\n\n\nhome directory\n主目录\n用户的主目录，Linux 中通常是 ~ 即 /home/&lt;user_name&gt;。\n\n\ninstance\n程序界面；实例\n这里指软件启动的一个实例，对于 RStudio 等大部分软件来说就是一个新的界面。\n\n\npane\n窗格\n窗格是对应用程序窗口的一个分割。\n\n\ntab\n选项卡\n选项卡是在窗格中展示的，可以切换不同的选项卡，窗格中将会展示对应的内容。\n\n\nsource package\n源码包\n指以源代码形式组织的软件包，通常是一个压缩文件，包含了软件包的所有源代码和元数据。\n\n\nbase R\nbase R\n指 R 语言的基础部分，有时也指 R 语言基础部分的编码风格，是相对于以 tidyverse 为代表的任何扩展包来说的。\n\n\nmorally\n从逻辑上讲\n这个词原意为“按照道义上的”，其翻译依赖于上下文语境，在编程领域可能更倾向于翻译为“从逻辑上讲”。\n\n\nunlist\n列表展开\n这里指将列表展开为向量。\n\n\nattach (library)\n载入（包）\n这里指载入包，使其可用。实际执行的是将包的路径“附加”到查找路径中。\n\n\ndemo\n演示示例\n这里指软件包中的演示示例，通常是一个 R 脚本，用于展示软件包的功能。\n\n\ndiff (in git)\n版本差异；文件差异\n可以参考 git 中的 diff 命令，用于比较两个版本或两个文件的差异。\n\n\npre-commit hook\n预提交钩子\n这里指 git 中的 pre-commit hook，是在执行 commit 命令前执行的脚本，可以用于在 commit 前执行一些操作，例如检查代码风格、运行测试等。\n\n\nlive code\n可实时运行的代码\n主要指 R Markdown 或其它任何形式的文档中，在生成文档时需要实时执行的代码。\n\n\nfile shuffling\n文件移动和重新组织操作\n这里指对文件进行移动、重命名、删除等操作，就像“洗牌”一样。\n\n\nlanding page\n落地页\n在网络营销和网站设计领域，landing page 是指用户通过点击广告或搜索结果等途径首次访问的网页。这里指软件包的主页，通常是软件包的 CRAN 或 GitHub 页面。\n\n\nrelease\n正式发布版本\n这里指软件在平台上正式发布的版本。\n\n\nBundled package\n归档包\n直译为“捆绑包”，但这里指软件包所有文件都被 tar 打包压缩为一个 .tar.gz 文件。由于“捆绑”一词具有歧义，且不是专业的计算机术语，因此这里借用 tar 和 source tarball 的含义， 翻译为“归档包”，表示它是一个包含了软件包的所有源代码和元数据的压缩文件，作为一个版本的归档压缩包。3\n\n\n\ncompilation artefacts\n编译产物\n这里指编译过程中产生的文件，例如编译后的二进制文件、编译日志等。\n\n\nanchoring (regex)\n定位锚点\n这里指标明正则表达式的定位锚点，用于在搜索文本时将模式限制在字符串的特定位置，例如 ^ 和 $。\n\n\nescaping (regex)\n转义\n这里指正则表达式中的转义，用于将特殊字符转义为普通字符，例如 \\.。",
    "crumbs": [
      "翻译与排版说明"
    ]
  },
  {
    "objectID": "translator-preface.html#排版说明",
    "href": "translator-preface.html#排版说明",
    "title": "翻译与排版说明",
    "section": "排版说明",
    "text": "排版说明\n由于书中不可避免地会同时出现中文和英文，因此原书的排版并不完全适用于中文翻译版。为了在尊重原书的基础上使页面变得美观，约定如下排版要求：\n\n英文单词、标点符号和数字各具有 1 个前导空格和 1 个后导空格。例如：“软件包的名称是 bookdown 吗。”。\n\n英文单词、标点和数字的一侧为标点符号时，该侧无空格。例如：“使用 Leading and Trailing Spaces。”。\n\n\n需要展示并链接 URL 时，将其放入尖括号内 &lt;&gt;。\n小括号内的文本包含中文时，使用中文小括号 （）；如果全是英文文本，则使用英文小括号 ()，并各具有 1 个前导和后导空格。\n书中某些操作中带有选项、菜单等名称，在实际操作时不具有中文翻译，此时列出该单词的中文翻译，后跟括号，括号内展示原英文单词。中文翻译便于读者查询相关资料，原英文单词便于按图索骥地进行操作。",
    "crumbs": [
      "翻译与排版说明"
    ]
  },
  {
    "objectID": "translator-preface.html#翻译进度",
    "href": "translator-preface.html#翻译进度",
    "title": "翻译与排版说明",
    "section": "翻译进度",
    "text": "翻译进度\n常言道，人生未填之坑十之八九。笔者学业繁忙，只能利用空闲时间翻译本书。因此在这里记录一下翻译进度，欢迎加入本项目提交 Pull Request。\n符号说明：\n\n✅：已完成\n⚙️：进行中\n📄：计划中\n\n\n\n章节\n是否翻译\n是否润色\n\n\n\nwelcome\n✅\n✅\n\n\nPreface\n✅\n✅\n\n\nIntroduction\n✅\n⚙️\n\n\nThe Whole Game\n✅\n⚙️\n\n\nSystem setup\n✅\n⚙️\n\n\nPackage structure and state\n⚙️\n\n\n\nFundamental development workflows\n\n\n\n\nThe package within\n\n\n\n\nR Code\n\n\n\n\nData\n\n\n\n\nOther components\n\n\n\n\nDESCRIPTION\n\n\n\n\nDependencies: Mindset and Background\n\n\n\n\nDependencies: In Practice\n\n\n\n\nLicensing\n\n\n\n\nTesting basics\n\n\n\n\nDesigning your test suite\n\n\n\n\nAdvanced testing techniques\n\n\n\n\nFunction documentation\n\n\n\n\nVignettes\n\n\n\n\nOther markdown files\n\n\n\n\nWebsite\n\n\n\n\nSoftware development practices\n\n\n\n\nLifecycle\n\n\n\n\nReleasing to CRAN\n\n\n\n\nReferences\n\n\n\n\nAppendix A R CND check",
    "crumbs": [
      "翻译与排版说明"
    ]
  },
  {
    "objectID": "translator-preface.html#footnotes",
    "href": "translator-preface.html#footnotes",
    "title": "翻译与排版说明",
    "section": "",
    "text": "见 https://en.wikipedia.org/wiki/Conscious_uncoupling↩︎\n译者注：需要再想清楚作者想表达的意思，然后润色↩︎\n译者注：“归档”一词在中国大陆的用语习惯中较少使用，但考虑 tar 的原意，确实有“为一个版本创建只读快照”的含义，和这里的 R 包相符。↩︎",
    "crumbs": [
      "翻译与排版说明"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "前言",
    "section": "",
    "text": "致谢\n自从 R Packages 第一版发布以来，支持本书描述的工作流的软件包已经有了广泛的发展。 最初的三个软件包 devtools, roxygen2 和 testthat 已经扩展到由 devtools “有意识地解耦”所创建的许多软件包，就如 2.2 devtools, usethis, 以及你自己 所描述的那样。 由于它们具有共同的根源 devtools，因此这些软件包多数源自 Hadley Wickham (HW)。 还有许多其他重要的贡献者，其中许多人现在是软件包的维护者：\n这本书是公开编写和修订的，它是社区努力的成果：许多人阅读草稿、修正错别字 、提出改进意见以及贡献内容。 没有这些贡献者，这本书不会像现在这样好，我们对他们的帮助深表感谢。 我们要感谢我们在 Posit 的同事，特别是 tidyverse 团队，他们一直很乐意讨论软件包的开发实践。 另外，我们出色的技术审查员团队提出的建议也极大地改进了本书：Malcolm Barrett, Laura DeCicco, Zhian Kamvar, Tom Mock 和 Maëlle Salmon。\nThanks to all contributors the the first and second editions (in alphabetical order by GitHub username):\n@aaelony, @aaronwolen (Aaron Wolen), @ablejec (Andrej Blejec), @adamcduncan (Adam Duncan), @adessy, @adrtod (Adrien Todeschini), @aghaynes (Alan Haynes), @agrueneberg (Alexander Grueneberg), @alejandrohagan (Alejandro Hagan), @alesantuz (Ale Santuz), @alexandrehsd (Alexandre Henrique), @alexholcombe (Alex O. Holcombe), @alexpghayes (alex hayes), @alforj (Justin Alford), @almartin82 (Andrew Martin), @aluxh (Alex Ho), @AmelZulji, @andreaphsz (Andrea Cantieni), @andrewdolman (Andrew Dolman), @andrewpbray (Andrew Bray), @AndrewsOR (John Andrews), @andycraig (Andrew Craig), @angela-li (Angela Li), @anjalisilva (Anjali Silva), @apomatix (Brad Friedman), @apreshill (Alison Presmanes Hill), @arashHaratian (Arash), @arilamstein (Ari Lamstein), @arneschillert (Arne Schillert), @arni-magnusson (Arni Magnusson), @asadow (Adam Sadowski), @ateucher (Andy Teucher), @avisser (Andy Visser), @ayormark (Adam Yormark), @azzaea (Azza Ahmed), @batpigandme (Mara Averick), @bclipp (Brian L), @beevabeeva, @behrman (Bill Behrman), @benmarwick (Ben Marwick), @BernhardKonrad (Bernhard Konrad), @bgreenwell (Brandon Greenwell), @Bisaloo (Hugo Gruson), @bklamer (Brett Klamer), @bm5tev3, @bms63 (Ben Straub), @bpbond (Ben Bond-Lamberty), @bquast (Bastiaan Quast), @Br-Johnson (Brett Johnson), @brews (Brewster Malevich), @brianrice2 (Brian Rice), @brry (Berry Boessenkool), @btruel, @calligross (Calli), @carldotac (Carl Lieberman), @carloscinelli (Carlos Cinelli), @CDCookJr, @cderv (Christophe Dervieux), @chambm (Matt Chambers), @charliejhadley (Charlie Joey Hadley), @chezou (Aki Ariga), @chsafouane (Safouane Chergui), @clente (Caio Lente), @cmarmstrong, @cooknl (CAPN), @CorradoLanera (Corrado Lanera), @craigcitro (Craig Citro), @crtahlin (Crt Ahlin), @daattali (Dean Attali), @danhalligan (Dan Halligan), @daroczig (Gergely Daróczi), @datarttu (Arttu Kosonen), @davidkane9 (David Kane), @DavisVaughan (Davis Vaughan), @deanbodenham, @dfalbel (Daniel Falbel), @dgrtwo (David Robinson), @dholstius (David Holstius), @DickStartz, @dkgaraujo (Douglas K. G. Araujo), @dlukes (David Lukes), @DOH-PXC5303 (Philip Crain), @dongzhuoer (Zhuoer Dong), @DougManuel (Doug Manuel), @dpprdan (Daniel Possenriede), @dracodoc (dracodoc), @drag05 (Dragos Bandur), @drvinceknight (Vince Knight), @dryzliang, @dyavorsky (Dan Yavorsky), @e-pet, @earino (E. Ariño de la Rubia), @echelleburns, @eeholmes (Eli Holmes), @eipi10 (Joel Schwartz), @ekbrown (Earl Brown), @EllaKaye (Ella Kaye), @EmilHvitfeldt (Emil Hvitfeldt), @eogoodwin, @erictleung (Eric Leung), @erikerhardt (Erik Erhardt), @espinielli (Enrico Spinielli), @ewan (Ewan Dunbar), @fbertran (Frederic Bertrand), @federicomarini (Federico Marini), @fenguoerbian (Chao Cheng), @fkohrt (Florian Kohrt), @florisvdh (Floris Vanderhaeghe), @floswald (Florian Oswald), @franrodalg (Francisco Rodríguez-Algarra), @franticspider (Simon Hickinbotham), @frycast (Daniel Vidali Fryer), @fsavje (Fredrik Sävje), @gajusmiknaitis, @gcpoole (Geoffrey Poole), @geanders (Brooke Anderson), @georoen (Jee Roen), @GerardTromp (Gerard Tromp), @GillesSanMartin (Gilles San Martin), @gmaubach (Georg Maubach), @gonzalezgouveia (Rafael Gonzalez Gouveia), @gregmacfarlane (Greg Macfarlane), @gregrs-uk (Greg), @grst (Gregor Sturm), @gsrohde (Scott Rohde), @guru809, @gustavdelius (Gustav W Delius), @haibin (Liu Haibin), @hanneoberman (Hanne Oberman), @harrismcgehee (Harris McGehee), @havenl (Haven Liu), @hcyvan (程一航), @hdraisma (Harmen), @hedderik (Hedderik van Rijn), @heists ((ꐦ°᷄д°)ა), @helske (Jouni Helske), @henningte (Henning Teickner), @HenrikBengtsson (Henrik Bengtsson), @heogden (Helen Ogden), @hfrick (Hannah Frick), @Holzhauer (Sascha Holzhauer), @howardbaek (Howard Baek), @howbuildingsfail (How Buildings Fail), @hq9000 (Sergey Grechin), @hrbrmstr (boB Rudis), @iangow (Ian Gow), @iargent, @idmn (Iaroslav Domin), @ijlyttle (Ian Lyttle), @imchoyoung (Choyoung Im), @InfiniteCuriosity (Russ Conte), @ionut-stefanb (Ionut Stefan-Birdea), @Ironholds (Os Keyes), @ismayc (Chester Ismay), @isomorphisms (i), @jackwasey (Jack Wasey), @jacobbien (Jacob Bien), @jadeynryan (Jadey Ryan), @jameelalsalam (Jameel Alsalam), @jameslairdsmith (James Laird-Smith), @janzzon (Stefan Jansson), @JayCeBB, @jcainey (Joe Cainey), @jdblischak (John Blischak), @jedwards24 (James Edwards), @jemus42 (Lukas Burk), @jenniferthompson (Jennifer Thompson), @jeremycg (Jeremy Gray), @jgarthur (Joey Arthur), @jimhester (Jim Hester), @jimr1603 (James Riley), @jjesusfilho (José de Jesus Filho), @jkeirstead (James Keirstead), @jmarca (James Marca), @jmarshallnz (Jonathan Marshall), @joethorley (Joe Thorley), @johnbaums (John), @jolars (Johan Larsson), @jonthegeek (Jon Harmon), @jowalski (John Kowalski), @jpinelo (Joao Pinelo Silva), @jrdnbradford (Jordan), @jthomasmock (Tom Mock), @julian-urbano (Julián Urbano), @jwpestrak, @jzadra (Jonathan Zadra), @jzhaoo (Joanna Zhao), @kaetschap (Sonja), @karthik (Karthik Ram), @KasperThystrup (Kasper Thystrup Karstensen), @KatherineCox, @katrinleinweber (Katrin Leinweber), @kbroman (Karl Broman), @kekecib (Ibrahim Kekec), @KellenBrosnahan, @kendonB (Kendon Bell), @kevinushey (Kevin Ushey), @kikapp (Kristopher Kapphahn), @KirkDSL, @KJByron (Karen J. Byron), @klmr (Konrad Rudolph), @KoderKow (Kyle Harris), @kokbent (Ben Toh), @kongdd (Dongdong Kong), @krlmlr (Kirill Müller), @kwenzig (Knut Wenzig), @kwstat (Kevin Wright), @kylelundstedt (Kyle G. Lundstedt), @lancelote (Pavel Karateev), @lbergelson (Louis Bergelson), @LechMadeyski (Lech Madeyski), @Lenostatos (Leon), @lindbrook, @lionel- (Lionel Henry), @LluisRamon (Lluís Ramon), @lorenzwalthert (Lorenz Walthert), @lwjohnst86 (Luke W Johnston), @maelle (Maëlle Salmon), @maiermarco, @maislind (David M), @majr-red (Matthew Roberts), @malcolmbarrett (Malcolm Barrett), @malexan (Alexander Matrunich), @manuelreif (Manuel Reif), @MarceloRTonon (Marcelo Tonon), @mariacuellar (Maria Cuellar), @markdly (Mark Dulhunty), @Marlin-Na (Marlin), @martin-mfg, @matanhakim (Matan Hakim), @matdoering, @matinang (Matina Angelopoulou), @mattflor (Matthias Flor), @maurolepore (Mauro Lepore), @maxheld83 (Max Held), @mayankvanani (Mayank Vanani), @mbjones (Matt Jones), @mccarthy-m-g (Michael McCarthy), @mdequeljoe (Matthew de Queljoe), @mdsumner (Michael Sumner), @michaelboerman (Michael Boerman), @MichaelChirico (Michael Chirico), @michaelmikebuckley (Michael Buckley), @michaelweylandt (Michael Weylandt), @miguelmorin, @MikeJohnPage, @mikelnrd (Michael Leonard), @mikelove (Mike Love), @mikemc (Michael McLaren), @MilesMcBain (Miles McBain), @mjkanji (Muhammad Jarir Kanji), @mkuehn10 (Michael Kuehn), @mllg (Michel Lang), @mohamed-180 (Mohamed El-Desokey), @moodymudskipper (Antoine Fabri), @Moohan (James McMahon), @MrAE (Jesse Leigh Patsolic), @mrcaseb, @ms609 (Martin R. Smith), @mskyttner (Markus Skyttner), @MWilson92 (Matthew Wilson), @myoung3, @nachti (Gerhard Nachtmann), @nanxstats (Nan Xiao), @nareal (Nelson Areal), @nattalides, @ncarchedi (Nick Carchedi), @ndphillips (Nathaniel Phillips), @nick-youngblut (Nick Youngblut), @njtierney (Nicholas Tierney), @nsheff (Nathan Sheffield), @osorensen (Øystein Sørensen), @PabRod (Pablo Rodríguez-Sánchez), @paternogbc (Gustavo Brant Paterno), @paulrougieux (Paul Rougieux), @pdwaggoner (Philip Waggoner), @pearsonca (Carl A. B. Pearson), @perryjer1 (Jeremiah), @petermeissner (Peter Meissner), @petersonR (Ryan Peterson), @petzi53 (Peter Baumgartner), @PhilipPallmann (Philip Pallmann), @philliplab (Phillip Labuschagne), @phonixor (Gerrit-Jan Schutten), @pkimes (Patrick Kimes), @pnovoa (Pavel Novoa), @ppanko (Pavel Panko), @pritesh-shrivastava (Pritesh Shrivastava), @PrzeChoj (PrzeChoj), @PursuitOfDataScience (Y. Yu), @pwaeckerle, @raerickson (Richard Erickson), @ramiromagno (Ramiro Magno), @ras44, @rbirkelbach (Robert Birkelbach), @rcorty (Robert W. Corty), @rdiaz02 (Ramon Diaz-Uriarte), @realAkhmed (Akhmed Umyarov), @reikookamoto (Reiko Okamoto), @renkun-ken (Kun Ren), @retowyss (Reto Wyss), @revodavid (David Smith), @rgknight (Ryan Knight), @rhgof (Richard), @rmar073, @rmflight (Robert M Flight), @rmsharp (R. Mark Sharp), @rnuske (Robert Nuske), @robertzk (Robert Krzyzanowski), @Robinlovelace (Robin Lovelace), @robiRagan (Robi Ragan), @Robsteranium (Robin Gower), @romanzenka (Roman Zenka), @royfrancis (Roy Francis), @rpruim (Randall Pruim), @rrunner, @rsangole (Rahul), @ryanatanner (Ryan), @salim-b (Salim B), @SamEdwardes (Sam Edwardes), @SangdonLim (Sangdon Lim), @sathishsrinivasank (Sathish), @sbgraves237, @schifferl (Lucas Schiffer), @scw (Shaun Walbridge), @sdarodrigues (Sabrina Rodrigues), @sebffischer (Sebastian Fischer), @serghiou (Stylianos Serghiou), @setoyama60jp, @sfirke (Sam Firke), @shannonpileggi (Shannon Pileggi), @Shelmith-Kariuki (Shel), @SheridanLGrant (Sheridan Grant), @shntnu (Shantanu Singh), @sibusiso16 (S’busiso Mkhondwane), @simdadim (Simen Buodd), @SimonPBiggs (SPB), @simonthelwall (Simon Thelwall), @SimonYansenZhao (Simon He Zhao), @singmann (Henrik Singmann), @Skenvy (Nathan Levett), @Smudgerville (Richard M. Smith), @sn248 (Satyaprakash Nayak), @sowla (Praer (Suthira) Owlarn), @srushe (Stephen Rushe), @statnmap (Sébastien Rochette), @steenharsted (Steen Harsted), @stefaneng (Stefan Eng), @stefanherzog (Stefan Herzog), @stephen-frank (Stephen Frank), @stephenll (Stephen Lienhard), @stephenturner (Stephen Turner), @stevenprimeaux (Steven Primeaux), @stevensbr, @stewid (Stefan Widgren), @sunbeomk (Sunbeom Kwon), @superdesolator (Po Su), @syclik (Daniel Lee), @symbolrush (Adrian Stämpfli-Schmid), @taekyunk (Taekyun Kim), @talgalili (Tal Galili), @tanho63 (Tan Ho), @tbrugz (Telmo Brugnara), @thisisnic (Nic Crane), @TimHesterberg (Tim Hesterberg), @titaniumtroop (Nathan), @tjebo, @tklebel (Thomas Klebel), @tmstauss (Tanner Stauss), @tonybreyal (Tony Breyal), @tonyfischetti (Tony Fischetti), @TonyLadson (Tony Ladson), @trickytank (Rick Tankard), @TroyVan, @uribo (Shinya Uryu), @urmils, @valeonte, @vgonzenbach (Virgilio Gonzenbach), @vladpetyuk (Vlad Petyuk), @vnijs (Vincent Nijs), @vspinu (Vitalie Spinu), @wcarlsen (Willi Carlsen), @wch (Winston Chang), @wenjie2wang (Wenjie Wang), @werkstattcodes, @wiaidp, @wibeasley (Will Beasley), @wilkinson (Sean Wilkinson), @williamlief (Lief Esbenshade), @winterschlaefer (Christof Winter), @wlamnz (William Lam), @wrathematics (Drew Schmidt), @XiangyunHuang (Xiangyun Huang), @xiaochi-liu (Xiaochi), @XiaoqiLu (Xiaoqi Lu), @xiaosongz (Xiaosong Zhang), @yihui (Yihui Xie), @ynsec37, @yonicd, @ysdgroot, @yui-knk (Yuichiro Kaneko), @Zedseayou (Calum You), @zeehio (Sergio Oller), @zekiakyol (Zeki Akyol), @zenggyu (Guangyu Zeng), @zhaoy, @zhilongjia (Zhilong), @zhixunwang, @zkamvar (Zhian N. Kamvar), @zouter (Wouter Saelens).",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#致谢",
    "href": "preface.html#致谢",
    "title": "前言",
    "section": "",
    "text": "devtools: HW, Winston Chang, Jim Hester (maintainer, &gt;= v1.13.5), Jennifer Bryan (maintainer &gt;= v2.4.3)\nusethis: HW, Jennifer Bryan (maintainer &gt;= v1.5.0), Malcolm Barrett\nroxygen2: HW (maintainer), Peter Danenburg, Manuel Eugster\n\ntestthat: HW (maintainer)\ndesc: Gábor Csárdi (maintainer), Kirill Müller, Jim Hester\n\npkgbuild: HW, Jim Hester, Gábor Csárdi (maintainer &gt;= v1.2.1)\npkgload: HW, Jim Hester, Winston Chang, Lionel Henry (maintainer &gt;= v1.2.4)\nrcmdcheck: Gábor Csárdi (maintainer)\nremotes: HW, Jim Hester, Gábor Csárdi (maintainer), Winston Chang, Martin Morgan, Dan Tenenbaum\n\nrevdepcheck: HW, Gábor Csárdi (maintainer)\nsessioninfo: HW, Gábor Csárdi (maintainer), Winston Chang, Robert Flight, Kirill Müller, Jim Hester\n\n\n\n#&gt; Warning: package 'tidyverse' was built under R version 4.2.3\n#&gt; Warning: package 'ggplot2' was built under R version 4.2.3\n#&gt; Warning: package 'tibble' was built under R version 4.2.3\n#&gt; Warning: package 'tidyr' was built under R version 4.2.3\n#&gt; Warning: package 'readr' was built under R version 4.2.3\n#&gt; Warning: package 'purrr' was built under R version 4.2.3\n#&gt; Warning: package 'dplyr' was built under R version 4.2.3\n#&gt; Warning: package 'stringr' was built under R version 4.2.3\n#&gt; Warning: package 'forcats' was built under R version 4.2.3\n#&gt; Warning: package 'lubridate' was built under R version 4.2.3\n#&gt; ── Attaching core tidyverse packages ──────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n#&gt; Rows: 410 Columns: 3\n#&gt; ── Column specification ────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (3): user, name, maybe_name\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#内容约定",
    "href": "preface.html#内容约定",
    "title": "前言",
    "section": "内容约定",
    "text": "内容约定\n在本书中，我们用 fun() 来指代函数，用 var 来指代变量和函数参数，用 path/ 来指代路径。\n较大的代码块同时包含输入和输出。 代码输出的内容都被注释了，因此如果你有本书的电子版本，例如 https://r-pkgs.org，就可以轻松地将示例代码复制和粘贴到 R 中。 输出内容的注释看起来像 #&gt;，这样可以和普通注释区别开来。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#colophon",
    "href": "preface.html#colophon",
    "title": "前言",
    "section": "Colophon1\n",
    "text": "Colophon1\n\n本书是在 RStudio 中使用 Quarto 编写的。 本书 官方网站 由 Netlify 托管，并使用 GitHub actions 在每次提交后自动更新。 完整的源代码可以在 GitHub 上找到\n本书的当前版本是在如下环境下构建的：\n\nlibrary(devtools)\n#&gt; Warning: package 'devtools' was built under R version 4.2.2\n#&gt; Loading required package: usethis\n#&gt; Warning: package 'usethis' was built under R version 4.2.3\nlibrary(roxygen2)\n#&gt; Warning: package 'roxygen2' was built under R version 4.2.3\nlibrary(testthat)\n#&gt; Warning: package 'testthat' was built under R version 4.2.3\n#&gt; \n#&gt; Attaching package: 'testthat'\n#&gt; The following object is masked from 'package:devtools':\n#&gt; \n#&gt;     test_file\n#&gt; The following object is masked from 'package:dplyr':\n#&gt; \n#&gt;     matches\n#&gt; The following object is masked from 'package:purrr':\n#&gt; \n#&gt;     is_null\n#&gt; The following objects are masked from 'package:readr':\n#&gt; \n#&gt;     edition_get, local_edition\n#&gt; The following object is masked from 'package:tidyr':\n#&gt; \n#&gt;     matches\ndevtools::session_info()\n#&gt; ─ Session info ───────────────────────────────────────────────────\n#&gt;  setting  value\n#&gt;  version  R version 4.2.1 (2022-06-23 ucrt)\n#&gt;  os       Windows 10 x64 (build 22000)\n#&gt;  system   x86_64, mingw32\n#&gt;  ui       RTerm\n#&gt;  language (EN)\n#&gt;  collate  Chinese (Simplified)_China.utf8\n#&gt;  ctype    Chinese (Simplified)_China.utf8\n#&gt;  tz       Asia/Taipei\n#&gt;  date     2024-02-16\n#&gt;  pandoc   3.1.1 @ D:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n#&gt; \n#&gt; ─ Packages ───────────────────────────────────────────────────────\n#&gt;  package     * version date (UTC) lib source\n#&gt;  bit           4.0.5   2022-11-15 [1] CRAN (R 4.2.3)\n#&gt;  bit64         4.0.5   2020-08-30 [1] CRAN (R 4.2.1)\n#&gt;  brio          1.1.3   2021-11-30 [1] CRAN (R 4.2.2)\n#&gt;  cachem        1.0.6   2021-08-19 [1] CRAN (R 4.2.1)\n#&gt;  callr         3.7.3   2022-11-02 [1] CRAN (R 4.2.3)\n#&gt;  cli           3.6.1   2023-03-23 [1] CRAN (R 4.2.3)\n#&gt;  colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.2.3)\n#&gt;  crayon        1.5.2   2022-09-29 [1] CRAN (R 4.2.3)\n#&gt;  devtools    * 2.4.5   2022-10-11 [1] CRAN (R 4.2.2)\n#&gt;  digest        0.6.34  2024-01-11 [1] CRAN (R 4.2.3)\n#&gt;  dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.2.3)\n#&gt;  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.2.1)\n#&gt;  evaluate      0.23    2023-11-01 [1] CRAN (R 4.2.3)\n#&gt;  fansi         1.0.3   2022-03-24 [1] CRAN (R 4.2.1)\n#&gt;  fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.2.3)\n#&gt;  forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.2.3)\n#&gt;  fs            1.6.2   2023-04-25 [1] CRAN (R 4.2.3)\n#&gt;  generics      0.1.3   2022-07-05 [1] CRAN (R 4.2.1)\n#&gt;  ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.2.3)\n#&gt;  glue          1.6.2   2022-02-24 [1] CRAN (R 4.2.1)\n#&gt;  gtable        0.3.3   2023-03-21 [1] CRAN (R 4.2.3)\n#&gt;  hms           1.1.3   2023-03-21 [1] CRAN (R 4.2.3)\n#&gt;  htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.2.3)\n#&gt;  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.2.3)\n#&gt;  httpuv        1.6.6   2022-09-08 [1] CRAN (R 4.2.1)\n#&gt;  jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.2.3)\n#&gt;  knitr         1.45    2023-10-30 [1] CRAN (R 4.2.3)\n#&gt;  later         1.3.0   2021-08-18 [1] CRAN (R 4.2.1)\n#&gt;  lifecycle     1.0.3   2022-10-07 [1] CRAN (R 4.2.2)\n#&gt;  lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.2.3)\n#&gt;  magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.2.1)\n#&gt;  memoise       2.0.1   2021-11-26 [1] CRAN (R 4.2.1)\n#&gt;  mime          0.12    2021-09-28 [1] CRAN (R 4.2.0)\n#&gt;  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.2.1)\n#&gt;  munsell       0.5.0   2018-06-12 [1] CRAN (R 4.2.1)\n#&gt;  pillar        1.9.0   2023-03-22 [1] CRAN (R 4.2.3)\n#&gt;  pkgbuild      1.4.1   2023-06-14 [1] CRAN (R 4.2.1)\n#&gt;  pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.2.1)\n#&gt;  pkgload       1.3.4   2024-01-16 [1] CRAN (R 4.2.3)\n#&gt;  prettyunits   1.1.1   2020-01-24 [1] CRAN (R 4.2.1)\n#&gt;  processx      3.8.3   2023-12-10 [1] CRAN (R 4.2.3)\n#&gt;  profvis       0.3.7   2020-11-02 [1] CRAN (R 4.2.2)\n#&gt;  promises      1.2.0.1 2021-02-11 [1] CRAN (R 4.2.1)\n#&gt;  ps            1.7.6   2024-01-18 [1] CRAN (R 4.2.3)\n#&gt;  purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.2.3)\n#&gt;  R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.1)\n#&gt;  Rcpp          1.0.9   2022-07-08 [1] CRAN (R 4.2.1)\n#&gt;  readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.2.3)\n#&gt;  remotes       2.4.2   2021-11-30 [1] CRAN (R 4.2.1)\n#&gt;  rlang         1.1.1   2023-04-28 [1] CRAN (R 4.2.3)\n#&gt;  rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.2.3)\n#&gt;  roxygen2    * 7.3.0   2024-01-11 [1] CRAN (R 4.2.3)\n#&gt;  rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.2.3)\n#&gt;  scales        1.2.1   2022-08-20 [1] CRAN (R 4.2.3)\n#&gt;  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.2)\n#&gt;  shiny         1.8.0   2023-11-17 [1] CRAN (R 4.2.3)\n#&gt;  stringi       1.8.3   2023-12-11 [1] CRAN (R 4.2.3)\n#&gt;  stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.2.3)\n#&gt;  testthat    * 3.2.1   2023-12-02 [1] CRAN (R 4.2.3)\n#&gt;  tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.2.3)\n#&gt;  tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.2.3)\n#&gt;  tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.2.2)\n#&gt;  tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.2.3)\n#&gt;  timechange    0.3.0   2024-01-18 [1] CRAN (R 4.2.3)\n#&gt;  tinytex       0.49    2023-11-22 [1] CRAN (R 4.2.3)\n#&gt;  tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.2.3)\n#&gt;  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.2.2)\n#&gt;  usethis     * 2.2.0   2023-06-06 [1] CRAN (R 4.2.3)\n#&gt;  utf8          1.2.2   2021-07-24 [1] CRAN (R 4.2.1)\n#&gt;  vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.2.3)\n#&gt;  vroom         1.6.3   2023-04-28 [1] CRAN (R 4.2.3)\n#&gt;  withr         3.0.0   2024-01-16 [1] CRAN (R 4.2.3)\n#&gt;  xfun          0.41    2023-11-01 [1] CRAN (R 4.2.3)\n#&gt;  xml2          1.3.3   2021-11-30 [1] CRAN (R 4.2.1)\n#&gt;  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.2.1)\n#&gt; \n#&gt;  [1] D:/R/R-4.2.1/library\n#&gt; \n#&gt; ──────────────────────────────────────────────────────────────────\n\n\n\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive Pretty Printing of R Code. http://styler.r-lib.org.",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#footnotes",
    "href": "preface.html#footnotes",
    "title": "前言",
    "section": "",
    "text": "译者注：版权页↩︎",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "简介",
    "section": "",
    "text": "开发理念\n本书宣扬了我们的软件包开发理念：凡是能够自动化的，都应该自动化。 尽量减少手动操作。 用函数完成尽可能多的事情。 这样是希望你将时间用于思考你想要让包做什么，而不是包结构的各种细节。\n这一理念主要是 devtools 包来实现的，这个软件包是让通用开发任务自动化的 R 函数套件中的代表。 devtools 在 2018 年 10 月发布了 2.0.0 版本，标志着其内部重组为一系列功能更具针对性的软件包，而它则更像是一个元软件包 (meta-package)。 usethis 包是其中你最有可能与之交互的子软件包，我们将在 2.2 devtools, usethis, 以及你自己 中解释 devtools 和 usethis 之间的关系。\n像往常一样，devtools 包的目的是让软件包的开发尽可能的轻松便利。 它囊括了 Hadley Wickham 自从作为一名多产的独立开发者以来积累的最佳实践经验。 最近，他在 Posit（以前称为 RStudio）组建了一个开发团队，共同维护数百个开源 R 包，包括那些被称为 the tidyverse 的包。 这个团队的能力让我们能够以惊人的规模探索所有可能出现的错误。 幸运的是，它还让我们有机会在专家和富有同情心的同事的陪伴下反思成功和失败。 我们试图开发出一些实践方法，让包的维护者和用户的工作更加轻松便利， 而 devtools 元软件包正是把这些经验教训具体化的地方。\ndevtools 与 RStudio 协同工作，我们相信这是对大多数 R 用户来说是最好的开发环境。 目前最流行的 RStudio 替代品是启用了 R extension 的 Visual Studio Code (VS Code)。 这可能是一个有价值并且功能强大的环境，然而它确实需要更多的工作来设置和定制3.\ndevtools 和 RStudio 一起，让你无需关注软件包是怎样构建的这种低级细节。 但是当你开始开发更多的软件包时，我们强烈建议你去了解这些细节。 有关软件包开发官方细节的最佳资源，始终是官方的 writing R extensions 手册4. 然而，如果你还不熟悉软件包的基础知识，这本使用手册可能难以理解。 它也十分详尽，涵盖了所有可能的软件包组件，而不是像本书那样只关注最常见和最有用的组件。 一旦你掌握了 R 包的基础知识，并且想深入了解其背后发生了什么，那么这本手册就是十分有用的资料。",
    "crumbs": [
      "简介"
    ]
  },
  {
    "objectID": "introduction.html#sec-intro-phil",
    "href": "introduction.html#sec-intro-phil",
    "title": "简介",
    "section": "",
    "text": "RStudio\n\n\n\n在整本书中，我们在像这样特殊格式的段落中强调了使用 RStudio 加速软件包开发工作流程的具体方法。",
    "crumbs": [
      "简介"
    ]
  },
  {
    "objectID": "introduction.html#intro-outline",
    "href": "introduction.html#intro-outline",
    "title": "简介",
    "section": "本书包含的内容",
    "text": "本书包含的内容\n本书的第一部分将为你提供软件包开发之旅所需的所有工具，强烈建议你按顺序阅读。 我们将在 1  整个流程 中介绍一个小软件包的完整开发过程。 在我们深入研究 R 包的关键组件之前，它旨在描绘出整体的图景并提出一个工作流程。 然后在 2  系统设置 你将学习如何为软件包开发准备好系统环境；在 3  软件包结构与状态 中，你将学习软件 包的基本结构以及它不同状态下的差异。 接下来，在 4  基本开发工作流 中，我们将介绍软件包开发人员经常遇到的核心工作流。 本书第一部分以另一个案例 (5  The package within) 作为结尾，这次重点介绍如何将脚本转换为包，并讨论在这个过程中可能面临的挑战。\n本书的其余部分可以根据需要进行阅读。 在你开发过程中面临各种问题时，可以在各章中进行选择阅读。\n我们首先介绍软件包中的关键组件：?sec-r 讨论代码的位置和组织方式，?sec-data 介绍如何在包中包含数据，?sec-misc 介绍几个需要在一些地方讨论，但不太重要的文件和目录。\n接下来，我们将从 ?sec-description 的 DESCRIPTION 文件开始，深入了解包的元数据。 在 ?sec-dependencies-mindset-background 中，我们将介绍使用依赖项的成本和收益，并提供一些关于包命名空间和搜索路径的技术背景知识。 在 ?sec-dependencies-in-practice 中，我们关注一些实际问题，比如如何在包的不同部分使用不同类型的依赖。 这也是我们讨论导出函数 (exporting functions) 的地方，这使得其他包和项目可以将你的包作为依赖项。 我们将在 ?sec-license 中以有关添加开源软件许可证的内容结束这一部分。\n为了确保软件包能按照设计正常工作（并在你修改代码后继续正常工作），测试你的代码是必不可少的工作，所以接下来的三章将介绍测试的艺术和科学。 ?sec-testing-basics 通过 testthat 包介绍测试的基础知识。 ?sec-testing-design 教你如何以最有效的方式设计和组织测试。 ?sec-testing-advanced 将结束对测试的介绍，这一章将教你处理具有挑战性的情况的高级技能。\n如果你想让其他人（包括未来的你！）理解如何使用包中的函数，就需要为它编写文档。 ?sec-man 开始教你使用 roxygen2 为包中的函数编写文档。 只有在你知道要查找哪个函数的时候，函数文档才有帮助。所以在 ?sec-vignettes 中，我们将讨论主题文档 (vignettes)，它可以帮助你为整个包提供文档。 我们将在 ?sec-other-markdown 结束对文档编写的介绍，这一章介绍其他重要的 markdown 文件，如 README.md 和 NEWS.md。?sec-website 则是介绍如何用 pkgdown 创建软件包网站。\n本书最后回顾了开发实践方法，例如使用版本控制和持续集成的好处 (?sec-sw-dev-practices)。 最后，我们会讨论软件包的生命周期 (?sec-lifecycle)，包括在CRAN上发布软件包 (?sec-release)。\n本书中有很多东西要学，但不要感到不知所措。 从一个最小的有用的功能子集（例如一个 R/ 目录！）开始，随着时间的推移逐步构建你的包。 套用禅僧铃木俊隆 (Shunryu Suzuki) 的话:“每个包都是完美的，就像它本来的模样——但是也许可以稍作改进。”5",
    "crumbs": [
      "简介"
    ]
  },
  {
    "objectID": "introduction.html#本书没有包含的内容",
    "href": "introduction.html#本书没有包含的内容",
    "title": "简介",
    "section": "本书没有包含的内容",
    "text": "本书没有包含的内容\n还有一些实践方法在本书中几乎没有讨论，这只是因为我们没有足够多地使用过它们，因此没有任何独特的见解。 这是否意味着我们应该尽量避免使用这些方法呢？ 可能并不是这样，因为我们在书中会试图明确地说明我们认为你应该避免使用的方法。 因此，如果有什么东西没有在本书中介绍，这只是意味着数百个被广泛使用的 R 包并没有依赖于这项技术。 这一结果应该能鼓励你去评估自己的开发需求与我们互不重叠的可能性。 但有时这个问题的答案是明确的“是”，在这种情况下，只需要去查阅其他的资料即可。\n\n\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r (and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.",
    "crumbs": [
      "简介"
    ]
  },
  {
    "objectID": "introduction.html#footnotes",
    "href": "introduction.html#footnotes",
    "title": "简介",
    "section": "",
    "text": "译者注：译者认为这里想要表达开发 R 包能带来一个明显的优势，即方便分享自己的代码，这一优势具有强烈的推动力和说服力，让你想要开发 R 包。↩︎\n“Seriously, it doesn’t have to be about sharing your code (although that is an added benefit!). It is about saving yourself time.”↩︎\nEmacs Speaks Statistics (ESS) 的用户将会发现本书中描述的许多工作流也可以在上面找到。 对于那些忠于 vim 的用户，我们推荐使用 Nvim-R plugin。↩︎\n你也可以在 https://rstudio.github.io/r-manuals/r-exts/ 上找到这本手册的 Quarto 版本。↩︎\n译者注：原话来自铃木俊隆的书籍《禅之初心》(Zen Mind, Beginner’s Mind)↩︎",
    "crumbs": [
      "简介"
    ]
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "1  整个流程",
    "section": "",
    "text": "1.1 加载 devtools 和 相关程序包\n你可以从任何活动的 R 会话中初始化新的软件包。 无需担心当前是在一个已存在的项目中还是新项目中， 我们使用的函数会确保为这个软件包创建一个新的干净的项目。\n首先需要加载 devtools 包, 它是一组支持软件包开发各个方面的包的公开接口。 其中最明显的是 usethis 包，你可以看到它也会被加载。\nlibrary(devtools)\n#&gt; Warning: package 'devtools' was built under R version 4.2.2\n#&gt; Loading required package: usethis\n#&gt; Warning: package 'usethis' was built under R version 4.2.3\n你现在安装的是旧版本的 devtools 包吗？ 比较一下你的版本和我们的版本，必要时可以进行升级。\npackageVersion(\"devtools\")\n#&gt; [1] '2.4.5'",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#示例软件包regexcite",
    "href": "whole-game.html#示例软件包regexcite",
    "title": "1  整个流程",
    "section": "\n1.2 示例软件包：regexcite",
    "text": "1.2 示例软件包：regexcite\n为了帮助你完成这个过程，我们使用 devtools 包中的各种函数从头开始构建一个小型示例软件包，其中包含了已发布软件包中常见的功能：\n\n用于满足特定需求的函数，在本例中是用于处理正则表达式的辅助函数。\n版本控制和开放的开发过程。\n\n在你的工作中这一配置是完全可选的，但我们强烈建议这样做。你将看到 Git 和 GitHub 如何帮助我们展示示例软件包开发的所有中间阶段。\n\n\n能够访问已建立的工作流程1，进行软件包安装、获取帮助和检查质量。\n\n使用 roxygen2 为每个函数建立文档。\n使用 testthat 进行单元测试。\n通过一个可执行的 README 文件 README.Rmd 来整体展示软件包。\n\n\n\n我们把这个软件包命名为 regexcite，它包含了几个函数，能够让使用正则表达式的常见任务变得更加容易。 请注意，这些函数非常简单，我们在这里使用它们只是为了引导你完成软件包开发过程。 如果你正在寻找使用正则表达式的辅助函数，这里有几个合适的 R 包可以解决这个问题：\n\n\nstringr（使用 stringi）\nstringi\nrex\nrematch2\n\n同样，regexcite 包本身只是一个设备，用于演示使用 devtools 进行软件包开发的典型工作流。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#看看成品",
    "href": "whole-game.html#看看成品",
    "title": "1  整个流程",
    "section": "\n1.3 看看成品",
    "text": "1.3 看看成品\n我们使用了 Git 版本控制系统来跟踪 regexcite 包开发的整个过程。 这一配置完全是可选的，你完全可以在不实现这一配置的情况下继续跟着进行其他步骤。 但是它有一个附加的好处，我们最终会将它连接到 GitHuub 上的远程储存库，这意味着你能够通过访问 GitHub 上的 regexcite 库来浏览我们努力取得的光荣成果： https://github.com/jennybc/regexcite。 通过检查 commit history，特别是版本差异，你可以准确地看到在下面列出的流程中，每个步骤发生了哪些更改。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#create_package",
    "href": "whole-game.html#create_package",
    "title": "1  整个流程",
    "section": "\n1.4 create_package()\n",
    "text": "1.4 create_package()\n\n调用 create_package() 来初始化计算机上指定目录中的新软件包。 如果该目录不存在，create_package() 将会自动创建该目录（通常都是这种情况）。 有关创建软件包的更多信息，请参阅 Section 4.1。\n慎重选择创建软件包的目录。 它应该在你的主目录 (home) 中，与其他 R 项目放在一起。 另外它不应该嵌套在其他 RStudio 项目、R 包或 Git 储存库中。 它也不应该在 R 软件包库 (R package library) 中，里面包含了已经构建和安装的包。 将我们在这里创建的源码包转换为已安装的包是 devtools 功能的一部分。 不要自己完成 devtools 能够完成的事情！\n一旦你选择了创建这个软件包的位置，将下面 create_package() 中的路径替换为你选择的路径并调用：\n\ncreate_package(\"~/path/to/regexcite\")\n\n为了创建这本书，我们必须在一个临时目录中工作，因为这本书是在云中以非交互方式构建的。 在幕后，我们正在执行我们自己的 create_package() 命令，如果我们的输出与你的略有不同，请不要感到惊讶。\n\n#&gt; ✔ Creating 'C:/Users/xiaob/AppData/Local/Temp/Rtmpk30OW9/regexcite/'\n#&gt; ✔ Setting active project to 'C:/Users/xiaob/AppData/Local/Temp/Rtmpk30OW9/regexcite'\n#&gt; ✔ Creating 'R/'\n#&gt; ✔ Writing 'DESCRIPTION'\n#&gt; Package: regexcite\n#&gt; Title: What the Package Does (One Line, Title Case)\n#&gt; Version: 0.0.0.9000\n#&gt; Authors@R (parsed):\n#&gt;     * First Last &lt;first.last@example.com&gt; [aut, cre] (YOUR-ORCID-ID)\n#&gt; Description: What the package does (one paragraph).\n#&gt; License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n#&gt;     license\n#&gt; Encoding: UTF-8\n#&gt; Roxygen: list(markdown = TRUE)\n#&gt; RoxygenNote: 7.3.0\n#&gt; ✔ Writing 'NAMESPACE'\n#&gt; ✔ Writing 'regexcite.Rproj'\n#&gt; ✔ Adding '^regexcite\\\\.Rproj$' to '.Rbuildignore'\n#&gt; ✔ Adding '.Rproj.user' to '.gitignore'\n#&gt; ✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\n\n如果你正在 RStudio 中工作，你应该会发现自己进入了一个新的 RStudio 程序界面，它在新的 regexcite 软件包项目目录中打开。 如果你出于某种原因需要手动执行这个操作，请进入该目录并双击 regexcite.Rproj。 RStudio 对于软件包项目做了特殊处理，你应该可以在 Environment 和 History 所在的窗格中看到一个 Build 选项卡。\n你可能需要再次调用 library(devtools)，因为 create_package() 可能已经在新的软件包目录中启动了一个新的 R 会话。\n\nlibrary(devtools)\n\n在这个新目录里的内容是一个 R 包，也许还是个 RStudio 项目？ 这里是一个文件清单（在本地，您可以查看 Files 窗格2）：\n\n\n\n\npath\ntype\n\n\n\n.gitignore\nfile\n\n\n.Rbuildignore\nfile\n\n\nDESCRIPTION\nfile\n\n\nNAMESPACE\nfile\n\n\nR\ndirectory\n\n\nregexcite.Rproj\nfile\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\n在 Files 窗格3中，依次点击 More（齿轮图标） &gt; Show Hidden Files 来切换隐藏文件（也称为 “dotfiles”）的可见性。 一些文件是始终可见的，但有时你可能会希望看到全部的文件。\n\n\n\n\n.Rbuildignore 列出了我们开发 R 包时需要的，但是从源代码构建 R 包时并不应该包含进来的文件。如果你不使用 RStudio，create_package() 一开始可能并不会创建这个文件（同样也不会创建 .gitignore），因为没有 RStudio 相关的机制需要被忽略。然而，无论你使用的是什么编辑器，都可能在某些时候产生对 .Rbuildignore 的需求。Section 3.3.1 将对此进行更加详细的讨论。\n\n.Rproj.user，如果有的话，它会是 RStudio 内部使用的目录。\n\n.gitignore 为 Git 的使用做好准备。它将忽略一些由 R 和 RStudio 创建的标准的幕后文件。即使你不打算使用 Git，它也并不会产生妨害。\n\nDESCRIPTION 提供了有关软件包的元数据。我们很快将开始编写这个文件，同时 ?sec-description 涵盖了 DESCRIPTION 文件的常用内容。\n\nNAMESPACE 声明了软件包导出以供外部使用的函数以及软件包从其他包导入的外部函数。现在，除了一个注释声明这是一个我们不应该手动编辑的文件外，它是空的。\n\nR/ 目录是你的软件包的“业务端”。它很快将包含带有函数声明的 .R 文件。\n\nregexcite.Rproj 是使得该目录成为 RStudio 项目的文件。即使你不使用 RStudio，这个文件也没有妨害。或者你可以使用 create_package(..., rstudio = FALSE) 来避免创建该文件，详见 Section 4.2。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_git",
    "href": "whole-game.html#use_git",
    "title": "1  整个流程",
    "section": "\n1.5 use_git()\n",
    "text": "1.5 use_git()\n\nregexcite 目录是一个 R 源码包，同时也是一个 RStudio 项目。 现在，我们使用 use_git() 让它变成一个 Git 储存库。 （顺便一提，use_git() 可以在任何项目中工作，不论它是否是一个 R 包。）\n\nuse_git()\n#&gt; ✔ Initialising Git repo\n#&gt; ✔ Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\n\n在交互式会话中，系统将询问你是否要在此处提交 (commit) 这些文件，一般来说会选择提交。 在幕后，我们也将提交这些相同的文件。\n那么在软件包中发生了什么变化呢？ 可以发现只创建了 .git 目录，这个目录在大多数环境中都是隐藏的，包括 RStudio 文件浏览器 它的存在证明我们确实在这个目录下初始化了 Git 存储库。\n\n\n\n\npath\ntype\n\n\n.git\ndirectory\n\n\n\n\n如果你使用的是 RStudio，它可能会请求在此项目中重新启动，遵从它的请求即可。 你也可以通过关闭 RStudio 然后双击 regexcite.Rproj 来手动重新启动RStudio。 现在，除了软件包的开发支持外，你也可以在 Environment/History/Build 窗格中的 Git 选项卡访问一个基础的 Git 客户端。\n\n点击 History（Git 窗格中的时钟图标），如果你之前同意了提交，你将会看到一个通过 use_git() 完成的初始提交。\n\n\n\n\ncommit\nauthor\nmessage\n\n\ndf926df8cd…\nYuanchenZhu2020 yuanchenzhu@126.com\n\nInitial commit\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\n只要你配置了 RStudio + Git 集成环境，RStudio 可以在任何项目中初始化一个 Git 储存库，即使该项目不是一个 R 软件包。 依次点击 Tools &gt; Version Control &gt; Project Setup。 然后选择 Version control system: Git 来为这个项目初始化一个新的 git 储存库。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#编写第一个函数",
    "href": "whole-game.html#编写第一个函数",
    "title": "1  整个流程",
    "section": "\n1.6 编写第一个函数",
    "text": "1.6 编写第一个函数\n在处理字符串时，一个相当常见的任务是需要将单个字符串拆分为许多部分。 base R中的 strsplit() 函数就是完成这个任务的。\n\n(x &lt;- \"alfa,bravo,charlie,delta\")\n#&gt; [1] \"alfa,bravo,charlie,delta\"\nstrsplit(x, split = \",\")\n#&gt; [[1]]\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n仔细看看返回值。\n\nstr(strsplit(x, split = \",\"))\n#&gt; List of 1\n#&gt;  $ : chr [1:4] \"alfa\" \"bravo\" \"charlie\" \"delta\"\n\n这个返回值的形状常常使人们感到惊讶，或者至少使他们感到不方便。 函数输入是长度为 1 的字符向量，而函数输出则是长度为 1 的列表。 考虑到 R 向矢量化演进的基本趋势，这是完全有意义的。 但有时它仍然有点讨人厌。 通常情况下，你知道你的输入在逻辑上是一个标量，即它只是一个单一的字符串，并且希望输出包含它各部分的字符向量。\n这导致 R 用户采用各种方法对输出结果进行列表展开 (unlist)：\n\nunlist(strsplit(x, split = \",\"))\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nstrsplit(x, split = \",\")[[1]]\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n上面的第二种更安全的解决方案是 regexcite 的首个函数 —— strsplit1() 的基础:\n\nstrsplit1 &lt;- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n这本书不会教你如何用 R 写函数。 要了解更多信息，请查看 R for Data Scienc 的 Functions chapter 以及 Advanced R 的 Functions chapter。\n\n\n\n\n\n\nTip\n\n\n\nstrsplit1() 的名字是对非常方便的 paste0() 的致敬，它首次出现在 2012 年的 R 2.15.0 中。 创建 paste0() 是为了解决 paste() 不使用分隔符将字符串连接在一起的极其常见的用例。 paste0() 被亲切地描述为 “statistical computing’s most influential contribution of the 21st century”.\nstrsplit1() 函数非常鼓舞人心，现在它是 stringr 包中的一个真正的函数： stringr::str_split_1()!",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_r",
    "href": "whole-game.html#use_r",
    "title": "1  整个流程",
    "section": "\n1.7 use_r()\n",
    "text": "1.7 use_r()\n\nstrsplit1() 的函数定义应该放在哪里呢？ 它应该被保存在软件包的 R/ 子目录下的 .R 文件中。 一个合理的处理方法是为包中每个面向用户的函数创建一个新的 .R 文件，并用函数名命名对应文件。 当你添加更多函数时，你可能会希望放宽一点这个要求，并将相关函数分组组织在一起。 我们将会把 strsplit1() 的函数定义保存在文件 R/strsplit1.R 中。\n辅助函数 use_r() 会在 R/ 目录下创建和（或）打开对应脚本文件。 在一个开发逐渐成熟的软件包中，当你需要在 .R 文件以及关联的测试文件之间切换时，它真的很好用。 但是，即使在目前刚开始开发的阶段，它在防止你自己沉迷于在 Untitled4 中工作也是很有帮助的。\n\nuse_r(\"strsplit1\")\n#&gt; • Edit 'R/strsplit1.R'\n\n将 strsplit1() 的函数定义，并且只有 strsplit1() 的函数定义放在 R/strsplit1.R 文件中并保存。 文件 R/strsplit1.R 不应该包含其他任何我们最近执行的顶层代码，例如我们用于实践的输入 x、library(devtools) 或 use_git()。 这预示着从编写 R 脚本过渡到编写 R 包时需要进行的调整。 软件包和脚本使用不同的机制来声明它们对其他包的依赖性，并存储示例或测试代码。 我们将在 ?sec-r 中进一步讨论这一点。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#sec-whole-game-load-all",
    "href": "whole-game.html#sec-whole-game-load-all",
    "title": "1  整个流程",
    "section": "\n1.8 load_all()\n",
    "text": "1.8 load_all()\n\n我们应该如何测试 strsplit1()？ 如果这是一个普通的 R 脚本，我们可以使用 RStudio 将函数定义发送到 R 控制台，并在全局环境中定义 strsplit1()。 或者我们可以调用 source(\"R/strsplit1.R\")。 然而，对于软件包开发来说，devtools 提供了一种更健壮的方法。\n调用 load_all() 来使 strsplit1() 可以用于测试运行。\n\nload_all()\n#&gt; ℹ Loading regexcite\n\n现在可以调用 strsplit1(x) 来看看它是如何工作的。\n\n(x &lt;- \"alfa,bravo,charlie,delta\")\n#&gt; [1] \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n请注意 load_all() 会使得 strsplit1() 函数可以使用，尽管它在全局环境中并不存在。\n\nexists(\"strsplit1\", where = globalenv(), inherits = FALSE)\n#&gt; [1] FALSE\n\n如果你的运行结果是 TRUE 而不是 FALSE，这意味着你仍然在使用面向脚本的工作流，并导入了你脚本的源代码。 下面是回到正轨的方法：\n\n清理你的全局环境并重启 R。\n使用 library(devtools) 重新载入 devtools 并调用 load_all() 来重新加载 regexcite 包。\n重新定义测试输入 x，然后再次调用 strsplit1(x, split = \",\")。这应该可以正常执行！\n再次运行 exists(\"strsplit1\", where = globalenv(), inherits = FALSE)，此时你应该可以看到输出了 FALSE。\n\nload_all() 模拟了构建、安装和载入 regexcite 软件包的过程。 当你的软件包积累了更多的函数时，有的函数导出供用户使用，而有的没有，有的函数会互相调用而有的从依赖的其他包中调用，使用 load_all() 相比于在全局工作空间中测试函数，能够使你对于软件包的开发过程有更为准确的了解。 同样的，load_all() 对于构建、安装和载入软件包的过程，能够允许更加快速的迭代。 有关 load_all() 的更多信息，请参阅 Section 4.4。\n到目前为止的内容：\n\n我们以及编写了第一个函数 strsplit1()，它用于将一个字符串拆分为一个字符向量（而不是包含字符向量的列表）。\n我们使用 load_all() 来快速地让这个函数可以用于交互式使用，就好像我们已经构建安装了 regexcite 并通过 library(regexcite) 载入了这个软件包一样。\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单中，或者在 Build 窗格中通过依次点击 More &gt; Load All 提供了 load_all() 的快捷调用，另外使用快捷键 Ctrl + Shift + L (Windows & Linux) 或 Cmd + Shift + L (macOS) 也可以快速调用该函数。\n\n\n\n1.8.1 提交对 strsplit1() 的更改\n如果你正在使用 Git，你可以使用你喜欢的方法来提交新的 R/strsplit1.R 文件。 我们在幕后也进行了这一操作，这是提交前后的差异。\n\ndiff --git a/R/strsplit1.R b/R/strsplit1.R\nnew file mode 100644\nindex 0000000..29efb88\n--- /dev/null\n+++ b/R/strsplit1.R\n@@ -0,0 +1,3 @@\n+strsplit1 &lt;- function(x, split) {\n+  strsplit(x, split = split)[[1]]\n+}\n\n从这一节后，我们会在每一步执行完后进行提交。 请记住这些提交在公开储存库中都是可见的。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#check",
    "href": "whole-game.html#check",
    "title": "1  整个流程",
    "section": "\n1.9 check()\n",
    "text": "1.9 check()\n\n我们现在有非正式的经验证据表明 strsplit1() 工作正常。 但是，我们如何确保 regexcite 包的所有可变部分仍然工作呢？ 在这么小的一个增加之后，检查其他部分似乎很愚蠢，但养成经常检查的习惯是很有益处的。\n在 shell 中执行的 R CMD check 是检查 R 包是否处于完全工作状态的黄金标准。 check() 是在不离开 R 会话的情况下运行这一操作的方便方法。\n请注意 check() 生成的输出相当庞大，针对交互式使用进行了优化。 我们在这里截取了一部分，并展示一个摘要。 你本地运行 check() 的输出会有所不同。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 26.9s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n0 errors ✔ | 1 warning ✖ | 0 notes ✔\n\n阅读检查的输出是十分必要的！请尽可能早并经常性地解决出现的问题。 这就像在 .R 和 .Rmd 文件上进行增量开发。 你检查每件事是否正常的时间间隔越长，就越难找到问题所在并解决问题。\n在这一步中，我们收到了 1 个警告 (warnings)（0 个错误 (errors)，0 个提示信息 (notes)）：\nNon-standard license specification:\n  `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n  license\n我们将会完全按照它所说的去做，完全解决这一问题。 你可以在 Section 4.5 中了解更多有关 check() 的信息。\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单中，或者在 Build 窗格中通过点击 Check 提供了 check() 的快捷调用，另外使用快捷键 Ctrl + Shift + E (Windows & Linux) 或 Cmd + Shift + E (macOS) 也可以快速调用该函数。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#编辑-description",
    "href": "whole-game.html#编辑-description",
    "title": "1  整个流程",
    "section": "\n1.10 编辑 DESCRIPTION\n",
    "text": "1.10 编辑 DESCRIPTION\n\nDESCRIPTION 文件提供了关于你的软件包的元数据，这在 ?sec-description 中有完整的介绍。 现在是查看 regexcite 当前 DESCRIPTION 的好时机。 你将看到它被填充了样板内容，这些内容需要替换\n要添加你自己的元数据，请进行以下编辑操作：\n\n让自己成为作者。如果你没有 ORCID，你可以忽略 comment = ... 部分。\n在 Title 和 Description 字段中写一些描述性文字。\n\n\n\n\n\n\n\nRStudio\n\n\n\n在 RStudio 中使用 Ctrl + . 然后输入 “DESCRIPTION” 来激活辅助功能，这样可以轻松打开指定文件进行编辑。 除了可以输入文件名外，还可以输入函数名。 当软件包具有大量文件时，这一功能十分便利。\n\n\n当你完成上面的操作后，DESCRIPTION 的文件内容应该和下面类似：\n\n\nPackage: regexcite\nTitle: Make Regular Expressions More Exciting\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"Jane\", \"Doe\", , \"jane@example.com\", role = c(\"aut\", \"cre\"))\nDescription: Convenience functions to make some common tasks with string\n    manipulation and regular expressions a bit easier.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.2",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_mit_license",
    "href": "whole-game.html#use_mit_license",
    "title": "1  整个流程",
    "section": "\n1.11 use_mit_license()\n",
    "text": "1.11 use_mit_license()\n\n\nPick a License, Any License. – Jeff Atwood\n\n我们目前在 DESCRIPTION 的 License 字段中有一个占位符，该占位符故意设置为无效的，并提供了一种解决方案。\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n要为软件包配置有效的许可证，请调用 use_mit_license()。\n\nuse_mit_license()\n#&gt; ✔ Adding 'MIT + file LICENSE' to License\n#&gt; ✔ Writing 'LICENSE'\n#&gt; ✔ Writing 'LICENSE.md'\n#&gt; ✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\n这将会把 License 字段正确地设置为 MIT 许可证，该许可证要求在 LICENSE 文件中写入版权持有人和年份。 打开新创建的 LICENSE 文件然后确保它看起来和下面的类似：\n\nYEAR: 2024\nCOPYRIGHT HOLDER: regexcite authors\n\n就像其他创建许可证的辅助函数一样，use_mit_license() 还会将完整的许可证副本放入 LICENSE.md 文件中，并将这个文件添加到 .Rbuildignore。 最好的做法是在软件包的源代码中包含完整的许可证文本，就像在 GitHub 中一样，但是 CRAN 禁止在软件包源代码中包含这一文件。 你可以在 ?sec-license 中找到更多有关添加许可证的内容。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#sec-whole-game-document",
    "href": "whole-game.html#sec-whole-game-document",
    "title": "1  整个流程",
    "section": "\n1.12 document()\n",
    "text": "1.12 document()\n\n就像其他 R 函数那样，在使用 strsplit1() 时能够获得帮助文档不是很好吗？ 这要求软件包具有特殊的 R 文档文件 man/strsplit1.Rd，这是一个以类似于 LaTeX 的 R 的特殊标记语言编写的文档。 幸运的是我们不需要直接编辑这类文档。\n我们在源代码文件中的 strsplit1() 函数上方直接编写一个特别格式的注释，然后让一个叫做 roxygen2 的软件包来完成 man/strsplit1.Rd 的创建。 roxygen2 设计的动机和机制将在 ?sec-man 中进行介绍。\n如果你使用 RStudio，则在源代码编辑器中打开 R/strsplit1.R，将光标放在 strsplit1() 函数定义中的某处。 然后依次点击 Code &gt; Insert roxygen skeleton。 函数上方应该会出现一个非常特殊的注释模板，每行以 # 开头。 RStudio 只插入模板框架，因此你需要对其进行编辑，如下所示。\n如果你不使用 RStudio，请自己创建注释。 无论使用哪种方式，你都应该修改注释，让它看起来像下面那样：\n\n#' Split a string\n#'\n#' @param x A character vector with one element.\n#' @param split What to split on.\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x &lt;- \"alfa,bravo,charlie,delta\"\n#' strsplit1(x, split = \",\")\nstrsplit1 &lt;- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n\n但是我们还没有完成！ 我们还需要使用 document() 开始执行将这个新的 roxygen 注释转换为 man/strsplit1.Rd 的过程：\n\ndocument()\n#&gt; ℹ Updating regexcite documentation\n#&gt; Setting `RoxygenNote` to \"7.3.0\"\n#&gt; ℹ Loading regexcite\n#&gt; Writing 'NAMESPACE'\n#&gt; Writing 'strsplit1.Rd'\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单中，或在 Build 窗格中通过 More &gt; Document 提供了 document() 的快捷调用，另外使用快捷键 Ctrl + Shift + D (Windows & Linux) 或 Cmd + Shift + D (macOS) 也可以快速调用该函数。\n\n\n你现在应该能够通过如下方式预览你的函数帮助文档：\n\n?strsplit1\n\n你将看到类似 “Rendering development documentation for ‘strsplit1’” 的提示信息，它告诉你，你基本上正在预览草稿文档。 也就是说，该文档存在于你的包的源代码中，但是尚未存在于已安装的包中。 事实上，我们还没有安装 regexcite，但很快就要安装了。 如果你发现 ?strsplit1 并不管用，你可能需要先调用 load_all()，然后再试一次。\n注意，在正式构建和安装之前，你的软件包的文档不会正确地关联起来。 这样就省去了一些细节，比如帮助文件之间的链接和软件包索引的创建。\n\n1.12.1 NAMESPACE 的更改\n除了将 strsplit1() 的特殊注释转化为 man/strsplit1.Rd，对 document() 的调用会基于在 roxygen 注释中找到的 @export 标签来更新 NAMESPACE 文件。 打开 NAMESPACE 进行检查。 其中的内容应该如下所示：\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(strsplit1)\n\n在通过 library(regexcite) 载入 regexcite 后，NAMESPACE 中的 export 指令使得 strsplit1() 对于用户来说可用。 就像完全有可能“手工”编写 .Rd 文件一样，你可以自己显式地管理 NAMESPACE。 但我们选择将这个任务委托给 devtools（以及 roxygen2）来完成。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#再次-check",
    "href": "whole-game.html#再次-check",
    "title": "1  整个流程",
    "section": "\n1.13 再次 check()\n",
    "text": "1.13 再次 check()\n\nregexcite 应该可以在现在并且永远干净地通过 R CMD check，并且 0 错误 (errors)，0 警告 (warnings)，0 提示信息 (notes)。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 24.3s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#install",
    "href": "whole-game.html#install",
    "title": "1  整个流程",
    "section": "\n1.14 install()\n",
    "text": "1.14 install()\n\n由于现在我们已经有了一个最小的可行软件包，让我们通过 install() 将 regexcite 包安装到你的库中：\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\xiaob\\AppData\\Local\\Temp\\Rtmpk30OW9\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/R/R-4.2.1/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\xiaob\\AppData\\Local\\Temp\\Rtmpk30OW9/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/R/R-4.2.1/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单中，或在 Build 窗格中通过 Install and Restart 提供了类似功能的快捷调用，另外使用快捷键 Ctrl + Shift + B (Windows & Linux) 或 Cmd + Shift + B (macOS) 也可以快速调用这一功能。\n\n\n安装完成后，我们可以像其他包一样载入和使用 regexcite。 让我们从头开始回顾我们的小型示例。 这也是重新启动 R 会话并确保你有一个干净的工作空间的好时机。\n\nlibrary(regexcite)\n\nx &lt;- \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n成功！",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_testthat",
    "href": "whole-game.html#use_testthat",
    "title": "1  整个流程",
    "section": "\n1.15 use_testthat()\n",
    "text": "1.15 use_testthat()\n\n我们已经在一个示例中非正式地测试了 strsplit1()。 我们还可以将其形式化为单元测试。 这意味着我们对于特定输入的 strsplit1() 的正确结果表达了明确的期望。\n首先，我们声明我们将使用 testthat 包中的 use_testthat() 来编写单元测试：\n\nuse_testthat()\n#&gt; ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n#&gt; ✔ Adding '3' to Config/testthat/edition\n#&gt; ✔ Creating 'tests/testthat/'\n#&gt; ✔ Writing 'tests/testthat.R'\n#&gt; • Call `use_test()` to initialize a basic test file and open it for editing.\n\n这将初始化软件包的单元测试机制。 它会将 Suggests: testthat 添加到 DESCRIPTION，创建目录 tests/testthat/，并添加脚本文件 tests/testthat.R。 你会注意到 testthat 可能添加了 3.0.0 的最小版本依赖要求，以及第二个 DESCRIPTION 字段 Config/testthat/edition: 3。 我们将会在 ?sec-testing-basics 中详细讨论这些细节。\n然而，是否编写实际的测试仍然取决于你！\n辅助函数 use_test() 用于打开并（或）创建测试文件。 你可以提供文件名，或者，如果你在 RStudio 中编辑相关的源文件，文件名将自动生成。 对于大部分人来说，如果 R/strsplit1.R 是 RStudio 中打开的文件，你只需要调用 use_test() 就好。 然而，由于本书是非交互构建的，我们必须显式地提供文件名：\n\nuse_test(\"strsplit1\")\n#&gt; ✔ Writing 'tests/testthat/test-strsplit1.R'\n#&gt; • Edit 'tests/testthat/test-strsplit1.R'\n\n它将会生成文件 tests/testthat/test-strsplit1.R。 如果该文件已经存在，use_test() 将只会打开它。 你会注意到在新创建的文件中有一个测试样例——你需要删除这些代码，并将以下内容添加到文件中:\n\ntest_that(\"strsplit1() splits a string\", {\n  expect_equal(strsplit1(\"a,b,c\", split = \",\"), c(\"a\", \"b\", \"c\"))\n})\n\n这将测试 strsplit1() 在分割字符串时是否给出预期的结果。\n交互式地运行这个测试，就像你编写自己的测试时会做的那样。 如果无法找到 test_that() 或 strsplit1()，那么这表示你可能需要调用 load_all()。\n在以后的过程中，你的测试大部分将主要通过 test() 以批量方式运行：\n\n\ntest()\n#&gt; ℹ Testing regexcite\n#&gt; ✔ | F W  S  OK | Context\n#&gt; \n#&gt; ⠏ |          0 | strsplit1                                          \n#&gt; ⠋ |          1 | strsplit1                                          \n#&gt; ✔ |          1 | strsplit1\n#&gt; \n#&gt; ══ Results ═════════════════════════════════════════════════════════\n#&gt; [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 在 Build 菜单中，或者在 Build 窗格中通过 More &gt; Test package 提供 test() 的快捷调用，另外使用快捷键 Ctrl + Shift + T (Windows & Linux) 或 Cmd + Shift + T (macOS) 也可以快速调用这一函数。\n\n\n每当你使用 check() 检查软件包时，你的测试也会运行。 这样，你基本上就可以使用一些特定于自己的包的检查来扩展标准检查。 使用 covr package 跟踪该测试所执行的源代码的比例也是一个好主意。 更多细节见 ?sec-testing-design-coverage。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_package",
    "href": "whole-game.html#use_package",
    "title": "1  整个流程",
    "section": "\n1.16 use_package()\n",
    "text": "1.16 use_package()\n\n在开发自己的软件包时，你不可避免地会想要在自己的包中使用另一个包中的函数。 要在我们的包中声明我们需要的其他包（即我们的依赖项），以及在我们的包中使用这些包，需要使用专用于软件包的方法来完成。 请注意，如果你计划将一个包提交到 CRAN，这种方法甚至适用于一些你认为是“始终可用”的包，例如 stats::median() 或 utils::head()。\n在使用 R 的正则表达式函数时，一个常见的困境是对于是否要求 perl = TRUE 或 perl = FALSE 存在不确定性。 此外，通常（但并非总是）还有其他参数会改变模式的匹配方式，例如 fixed、ignore.case 和 invert。 跟踪哪个函数使用了哪个参数以及参数之间如何交互是一件很困难的事，因此许多用户在不重复读文档的情况下永远不会记住这些细节。\nstringr 包“提供了一组协调一致的函数，旨在使处理字符串变得尽可能简单”。 具体而言，stringr 在所有地方都使用一个正则表达式系统（ICU 正则表达式），并在每个函数中使用相同的接口来控制匹配行为，比如大小写敏感性。 一些人发现这样更容易内化知识和编程。 让我们假设你决定基于 stringr（和 stringi）构建 regexcite，而不是基于 R 的基础正则表达式函数。\n首先，通过使用 use_package() 来声明你的通用意图，即使用 stringr 命名空间中的一些函数：\n\nuse_package(\"stringr\")\n#&gt; ✔ Adding 'stringr' to Imports field in DESCRIPTION\n#&gt; • Refer to functions with `stringr::fun()`\n\n这一命令会把 stringr 包加入到 DESCRIPTION 的 Imports 字段。 这就是它的全部功能。\n让我们重新回到 strsplit1()，使它更像 stringr 的风格。 这里有一个新的实现方案4:\n\nstr_split_one &lt;- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) &lt;= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\n请注意，我们：\n\n将函数重命名为 str_split_one()，以表示它是 stringr::str_split() 的一个封装。\n采用了 stringr::str_split() 的参数名称。现在我们有了 string 和 pattern（以及 n），而不是 x 和 split。\n引入了一些参数检查和边界情况处理。这与切换到 stringr 无关，并且在基于 strsplit() 构建的版本中同样有益。\n在调用 stringr::str_split() 时使用了 package::function() 形式。这指定我们要从 stringr 命名空间中调用 str_split() 函数。从另一个包中调用函数的方法不止一种，而我们在这里建议的方法在 ?sec-dependencies-in-practice 中有完整的解释。\n\n我们应该在哪里写这个新的函数定义？ 如果我们想继续遵循我们将 .R 文件命名为其中定义的函数的约定，那么我们现在需要进行一些繁琐的文件移动和重新组织的操作。 因为这在现实生活中经常出现，所以我们使用了 rename_files() 函数, 它会协调在 R/ 目录下的文件重命名以及与之相关的 test/ 目录下伴随文件的重命名。\n\nrename_files(\"strsplit1\", \"str_split_one\")\n#&gt; ✔ Moving 'R/strsplit1.R' to 'R/str_split_one.R'\n#&gt; ✔ Moving 'tests/testthat/test-strsplit1.R' to 'tests/testthat/test-str_split_one.R'\n\n请记住：对文件名进行操作远远不够。 我们仍然需要更新这些文件的内容！\n以下是 R/str_split_one.R 的更新内容。 除了更改函数定义之外，我们还更新了 roxygen 注释以反映参数的更新，并包含展示 stringr 特性的示例。\n\n#' Split a string\n#'\n#' @param string A character vector with, at most, one element.\n#' @inheritParams stringr::str_split\n#'\n#' @return A character vector.\n#' @export\n#'\n#' @examples\n#' x &lt;- \"alfa,bravo,charlie,delta\"\n#' str_split_one(x, pattern = \",\")\n#' str_split_one(x, pattern = \",\", n = 2)\n#'\n#' y &lt;- \"192.168.0.1\"\n#' str_split_one(y, pattern = stringr::fixed(\".\"))\nstr_split_one &lt;- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) &lt;= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\n别忘了也要更新测试文件！\n以下是 tests/testthat/test-str_split_one.R 的更新内容。 除了更改函数的名称和参数之外，我们还添加了几个测试。\n\ntest_that(\"str_split_one() splits a string\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\"), c(\"a\", \"b\", \"c\"))\n})\n\ntest_that(\"str_split_one() errors if input length &gt; 1\", {\n  expect_error(str_split_one(c(\"a,b\",\"c,d\"), \",\"))\n})\n\ntest_that(\"str_split_one() exposes features of stringr::str_split()\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\", n = 2), c(\"a\", \"b,c\"))\n  expect_equal(str_split_one(\"a.b\", stringr::fixed(\".\")), c(\"a\", \"b\"))\n})\n\n在我们导出新的 str_split_one() 进行测试之前，我们需要调用 document()。 为什么呢？ 请记住 document() 做了两件主要的工作：\n\n将我们的 roxygen 注释转换为适当的 R 文档。\n（重新）生成 NAMESPACE。\n\n第二个工作在这里特别重要，因为我们将不再导出 strsplit1()，而是导出新的 str_split_one()。 不要对 \"Objects listed as exports, but not present in namespace: strsplit1\" 的警告感到沮丧。 当你从命名空间中删除某些内容时，这种情况总是会发生。\n\ndocument()\n#&gt; ℹ Updating regexcite documentation\n#&gt; ℹ Loading regexcite\n#&gt; Warning: Objects listed as exports, but not present in namespace:\n#&gt; • strsplit1\n#&gt; Writing 'NAMESPACE'\n#&gt; Writing 'str_split_one.Rd'\n#&gt; Deleting 'strsplit1.Rd'\n\n通过 load_all() 模拟软件包安装，试试新的 str_split_one() 函数：\n\nload_all()\n#&gt; ℹ Loading regexcite\nstr_split_one(\"a, b, c\", pattern = \", \")\n#&gt; [1] \"a\" \"b\" \"c\"",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_github",
    "href": "whole-game.html#use_github",
    "title": "1  整个流程",
    "section": "\n1.17 use_github()\n",
    "text": "1.17 use_github()\n\n你已经看到我们在 regexcite 的开发过程中进行了许多提交。 你可以在 https://github.com/jennybc/regexcite 中看到指示性的提交历史记录 我们使用版本控制系统并公开开发过程的决定意味着你可以在每个开发阶段检查 regexcite 源代码的状态。 通过查看所谓的文件差异 (diff)，你可以确切地看到每个 devtools 辅助函数是如何修改构成 regexcite 软件包的源文件的。\n如何将你的本地 regexcite 软件包和 Git 存储库连接到 GitHub 上的配套存储库呢？ 这里有三种方法：\n\n\nuse_github() 是我们一直以来推荐使用的辅助函数。我们不会在这里演示，因为它需要在你的主机端进行一些登录凭证的设置。我们也不想在每次建立这本书的时候都删除和重建公共 regexcite 软件包储存库。\n先设置 GitHub 储存库！这听起来有悖常理，但把你的工作放到 GitHub 托管的最简单方法是在那里初始化，然后使用 RStudio 在同步的本地副本中开始工作。这种方法在 Happy Git 的工作流 New project, GitHub first 和 Existing project, GitHub first 中进行了描述。\n命令行 Git (Command line Git) 始终可以用于在事后添加远程存储库。这在 Happy Git 工作流 Existing project, GitHub last 中进行了描述。\n\n这些方法都会将你的本地 regexcite 项目连接到公共或私有的 GitHub 储存库，你可以使用 RStudio 中内置的 Git 客户端来推送 (push) 或拉取 (pull) 它。 在 ?sec-sw-dev-practices 中，我们详细说明了为什么版本控制（例如 Git），特别是托管版本控制（例如 GitHub）值得合并到软件包开发过程中。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_readme_rmd",
    "href": "whole-game.html#use_readme_rmd",
    "title": "1  整个流程",
    "section": "\n1.18 use_readme_rmd()\n",
    "text": "1.18 use_readme_rmd()\n\n现在你的软件包已经公开到 GitHub 上了，那么 README.md 文件就很重要。 它是软件包的主页和欢迎界面，至少在你决定为它建立一个网站（见 ?sec-website），添加一份主题文档 (vignette)（见 ?sec-vignettes），或者提交到 CRAN（见 ?sec-release）之前是这样。\nuse_readme_rmd() 函数的作用是初始化一个基础的，可执行的 README.Rmd 以供你编辑：\n\nuse_readme_rmd()\n#&gt; ✔ Writing 'README.Rmd'\n#&gt; ✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n#&gt; • Update 'README.Rmd' to include installation instructions.\n#&gt; ✔ Writing '.git/hooks/pre-commit'\n\n除了创建 README.Rmd 外，它还会在 .Rbuildignore 添加几行内容并创建一个 Git 预提交钩子 (pre-commit hook) 来帮助你保持 README.Rmd 和 README.md 的同步。\nREADME.Rmd 中已经包含了一些部分，提示你：\n\n描述开发这个软件包的目的。\n提供安装说明。如果在调用 use_readme_rmd() 时检测到已配置 GitHub 远程仓库，这一节将预先填充如何从 GitHub 进行安装的说明。\n展示一些用法\n\n如何填充这个内容框架？ 可以从 DESCRIPTION 和任何正式或非正式的测试和示例中大量复制内容。 有内容总比没有好。 这很有帮助，因为人们可能不会安装你的软件包并仔细检查各个帮助文件来弄清楚如何使用它。\n我们喜欢使用 R Markdown 编写 README，这样它就可以展示实际用法。 包含可实时运行的代码能够减少你的 README 变得过时，并且与实际的软件包不同步的可能性。\n如果 RStudio 还没有像上面描述的那样做，请打开 README.Rmd 自己进行编辑。 确保它显示了 str_split_one() 的一些用法。\n我们使用的 README.Rmd 可以在这里找到：README.Rmd，以下是该文件的内容：\n\n---\noutput: github_document\n---\n\n&lt;!-- README.md is generated from README.Rmd. Please edit that file --&gt;\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n\n**NOTE: This is a toy package created for expository purposes, for the second edition of [R Packages](https://r-pkgs.org). It is not meant to actually be useful. If you want a package for factor handling, please see [stringr](https://stringr.tidyverse.org), [stringi](https://stringi.gagolewski.com/),\n[rex](https://cran.r-project.org/package=rex), and\n[rematch2](https://cran.r-project.org/package=rematch2).**\n\n# regexcite\n\n&lt;!-- badges: start --&gt;\n&lt;!-- badges: end --&gt;\n\nThe goal of regexcite is to make regular expressions more exciting!\nIt provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.\n\n## Installation\n\nYou can install the development version of regexcite from [GitHub](https://github.com/) with:\n      \n``` r\n# install.packages(\"devtools\")\ndevtools::install_github(\"jennybc/regexcite\")\n```\n\n## Usage\n\nA fairly common task when dealing with strings is the need to split a single string into many parts.\nThis is what `base::strplit()` and `stringr::str_split()` do.\n\n```{r}\n(x &lt;- \"alfa,bravo,charlie,delta\")\nstrsplit(x, split = \",\")\nstringr::str_split(x, pattern = \",\")\n```\n\nNotice how the return value is a **list** of length one, where the first element holds the character vector of parts.\nOften the shape of this output is inconvenient, i.e. we want the un-listed version.\n\nThat's exactly what `regexcite::str_split_one()` does.\n\n```{r}\nlibrary(regexcite)\n\nstr_split_one(x, pattern = \",\")\n```\n\nUse `str_split_one()` when the input is known to be a single string.\nFor safety, it will error if its input has length greater than one.\n\n`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.\n\n```{r}\nstr_split_one(x, pattern = \",\", n = 2)\n\ny &lt;- \"192.168.0.1\"\nstr_split_one(y, pattern = stringr::fixed(\".\"))\n```\n\n别忘了渲染该文件以生成 README.md！ 如果你尝试提交 README.Rmd 而不是 README.md，或者 README.md 已经过时了，预提交钩子 (pre-commit hook) 应该会提示你。\n渲染 README.Rmd 的最好方法是使用 build_readme()，因为它会注意使用软件包的最新版本来进行渲染， 即它会从当前包的源代码中安装一个临时副本进行渲染。\n\nbuild_readme()\n#&gt; ℹ Installing regexcite in temporary library\n#&gt; ℹ Building\n#&gt;   'C:/Users/xiaob/AppData/Local/Temp/Rtmpk30OW9/regexcite/README.Rmd'\n\n你只需要简单地访问 GitHub 上的 regexcite就可以看到已经渲染好的 README.md。\n最后，别忘了做最后一次提交。 如果你使用了 GitHub，还需要推送至远程仓库。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#最后一步check然后-install",
    "href": "whole-game.html#最后一步check然后-install",
    "title": "1  整个流程",
    "section": "\n1.19 最后一步：check()，然后 install()\n",
    "text": "1.19 最后一步：check()，然后 install()\n\n让我们再次运行 check()，确保软件包仍然一切正常。\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 25.7s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nregexcite 应该没有错误 (errors)、警告 (warnings) 或提示信息 (notes)。 现在是重新构建和安装软件包的最好时机。 庆祝一下！\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file 'C:\\Users\\xiaob\\AppData\\Local\\Temp\\Rtmpk30OW9\\regexcite/DESCRIPTION' ... OK\n* preparing 'regexcite':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building 'regexcite_0.0.0.9000.tar.gz'\nRunning \"D:/R/R-4.2.1/bin/x64/Rcmd.exe\" INSTALL \\\n  \"C:\\Users\\xiaob\\AppData\\Local\\Temp\\Rtmpk30OW9/regexcite_0.0.0.9000.tar.gz\" \\\n  --install-tests \n* installing to library 'D:/R/R-4.2.1/library'\n* installing *source* package 'regexcite' ...\n** using staged installation\n** R\n** tests\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n请随意访问 GitHub 上的 regexcite 软件包，它看起来和这里开发的完全一样。 提交历史记录反映了每一个单独的步骤，因此你可以使用 diffs 来查看在软件包开发过程中哪些文件被添加和修改。 本书的其余部分将更详细地介绍你在这里看到的每一个步骤以及其它更多的内容。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#回顾",
    "href": "whole-game.html#回顾",
    "title": "1  整个流程",
    "section": "\n1.20 回顾",
    "text": "1.20 回顾\n这一章的目的是给你一个典型的软件包开发流程的印象，可以总结为 Figure 1.1 所示的流程图。 除了 GitHub Actions 外，你在这里看到的所有内容都已经在这一章中提到过了，你将在 ?sec-sw-dev-practices-gha 中学到更多。\n\n\n\n\n\n\n\nFigure 1.1: devtools 软件包开发工作流程。\n\n\n\n\n下面是对本章中提到的关键函数的回顾，根据它们在开发流程中的角色进行了粗略的组织。\n这些函数用于配置软件包的各个部分，通常对于每个软件包只需要调用一次：\n\ncreate_package()\nuse_git()\nuse_mit_license()\nuse_testthat()\nuse_github()\nuse_readme_rmd()\n\n当你添加函数、测试代码或依赖项时，将会定期调用这些函数：\n\nuse_r()\nuse_test()\nuse_package()\n\n在开发过程中，你将每天或每小时频繁调用这些函数：\n\nload_all()\ndocument()\ntest()\ncheck()",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "whole-game.html#footnotes",
    "href": "whole-game.html#footnotes",
    "title": "1  整个流程",
    "section": "",
    "text": "译者注：可能指能够执行例如安装、构建文档等标准工作流程。↩︎\n译者注：原文为 pane，准确来说是 tab。↩︎\n译者注：原文为 pane，准确来说是 tab。↩︎\n回想一下，这个例子是如此鼓舞人心，以至于它现在是 stringr 包中的一个真正的函数： `stringr::str_split_1()`！↩︎",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>整个流程</span>"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "2  系统设置",
    "section": "",
    "text": "2.1 准备好你的系统\n在开始之前，请确保您已经安装了最新版本的 R（至少需要 4.2.1，本书即是使用该版本渲染生成的），然后再运行以下代码来获取您将使用到的程序包：\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))\n请确保您已经安装了最新版本的 RStudio 集成开发环境（IDE）。 新版本会定期发布，所以我们建议经常更新以获得最新和最好的功能。\n从这里下载最新版本的 RStudio Desktop：https://posit.co/download/rstudio-desktop/。 大多数读者可以使用 RStudio Desktop 的免费开源版本。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>系统设置</span>"
    ]
  },
  {
    "objectID": "setup.html#sec-setup-usage",
    "href": "setup.html#sec-setup-usage",
    "title": "2  系统设置",
    "section": "\n2.2 devtools, usethis, 以及你自己",
    "text": "2.2 devtools, usethis, 以及你自己\n\n“I am large, I contain multitudes.”\n— Walt Whitman, Song of Myself\n\n正如在 Section 1 中所提到的，devtools 是一个“元软件包 (meta-package)”，包含并提供了在几个较小的包中维护的功能1。 例如，devtools 可能会提供一个包装器函数 (wrapper function)，以设置用户友好的默认值，引入有用的交互行为，或组合来自多个子软件包的功能。 在某些情况下，它只是从另一个包中重新导出一个函数，以便在使用 (attach)2 devtools 时能够方便地使用它。\n那么我们推荐使用 devtools 及其组成软件包的方法是什么呢？ 根据你的意图有不同的使用方法：\n\n如果你正在交互式地使用这些函数来帮助开发软件包，则应将 devtools 视为首选的用于包开发的函数提供者。在这种情况下，你应该将使用 library(devtools) 附加 devtools 并在不加限定符的情况下调用函数（例如 load_all()）。\n如果你正在编写包代码并使用 devtools 和相关函数，则不应该依赖 devtools，而应通过是它们所在的软件包来访问函数。\n\ndevtools 应该尽量避免以形如 pkg::fcn() 的限定调用的形式出现在 pkg 中。相对地，pkg 应该是 fcn() 的函数定义所在的包。例如，如果你要在包中创建一个函数，在函数内你需要查询用户 R session 的状态，请在你的包中使用 sessioninfo::session_info() 而不是 devtools::session_info()。\n\n\n如果你发现了漏洞，请尝试在作为函数主要宿主的包上报告它们。devtools::fcn() 的帮助文档通常说明了 devtools 何时从另一个包中重新导出一个函数。\n\nusethis 软件包是更多人可能知道并直接使用的组成软件包。 它包含了操作 R 项目中文件和文件夹的函数，特别是对于任何既是 R 项目又是 R 软件包的项目。 devtools 让你可以轻松地以交互式方法使用 usethis 函数，当你调用 library(devtools) 时，usethis 也会被附加。 然后，你可以在不加限定符的情况下使用 usethis 中的任何函数，例如，可以调用 use_testthat()。 如果你选择指定命名空间，例如在更程序化的风格下工作时，请确保使用 usethis 对调用进行限定，例如，usethis::use_testthat()。\n\n2.2.1 个人启动配置\n你可以通过以下方式附加 (attach) devtools 程序包：\n\nlibrary(devtools)\n\n但是，在每个 R session 中重复附加 devtools 很快就会变得令人恼火。 因此，我们强烈建议将 devtools 附加3到你的 .Rprofile 启动文件中, 如下所示：\n\nif (interactive()) {\n  suppressMessages(require(devtools))\n}\n\n为了方便起见， use_devtools() 函数会在你需要时创建 .Rprofile 文件，将其打开并进行编辑，然后在剪切板和屏幕上放置必要的代码行。\n\n\n\n\n\n\nWarning\n\n\n\n一般来说，在 .Rprofile 中附加软件包是一个坏主意，因为它会让你创建无法通过显式调用 library(foo) 来反映所有依赖关系的 R 脚本。 但是 devtools 是一个工作流包，它用于简化软件包开发过程，因此不太可能被嵌入到任何分析脚本中。 请注意，我们仍然注意只在交互式会话中附加软件包。\n\n\nusethis 会查找某些选项，例如当你从头 (de novo) 开始创建软件包时。 这允许你为自己（作为软件包维护者）或你的首选许可证指定个人默认值。 下面是一个可以进入 .Rprofile 的代码片段示例：\n\noptions(\n  \"Authors@R\" = utils::person(\n    \"Jane\", \"Doe\",\n    email = \"jane@example.com\",\n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"0000-1111-2222-3333\")\n  ),\n  License = \"MIT + file LICENSE\"\n)\n\n以下代码展示了如何安装 devtools 和 usethis 的开发版本。 有时，本书可能会介绍 devtools 和相关软件包的开发版本中尚未发布的新功能。\n\ndevtools::install_github(\"r-lib/devtools\")\ndevtools::install_github(\"r-lib/usethis\")\n\n# or, alternatively\npak::pak(\"r-lib/devtools\")\npak::pak(\"r-lib/usethis\")",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>系统设置</span>"
    ]
  },
  {
    "objectID": "setup.html#setup-tools",
    "href": "setup.html#setup-tools",
    "title": "2  系统设置",
    "section": "\n2.3 R 构建工具链",
    "text": "2.3 R 构建工具链\n要能够完全从源代码构建 R 软件包，还需要一个编译器和其他一些命令行工具。 这可能不是严格必须的，除非你想构建包含 C 或 C++ 代码的程序包。 特别是如果你正在使用 RStudio，可以暂时把它放在一边。 一旦你尝试执行需要设置开发环境的操作，IDE 将发出警报并提供支持。 请阅读下面的建议，了解如何自己做到这一点。\n\n2.3.1 Windows\n在 Windows 上，从源代码构建程序包所需要的工具集叫做 RTools。\nRtools 不是 R 软件包。 它不是通过 install.packages() 进行安装。 而是通过从 https://cran.r-project.org/bin/windows/Rtools/ 下载并运行安装程序来安装。\n在 RTools 的安装过程中，您可能会看到一个窗口，它询问您是否“Select Additional Tasks”。\n\n\n不要选中“Edit the system PATH”。devtools 和 Rstudio 会在需要时自动将 RTools 放入 PATH。\n选中 “Save version information to registry”。它应该是默认选中的。\n\n2.3.2 macOS\n你需要安装 Xcode 命令行工具，这需要你注册成为 Apple 开发人员（不用担心，对于哪些只希望安装应用程序，例如 Xcode 命令行工具的个人来说是免费的。只有那些想要发布应用程序、访问测试版软件并集成Siri、Apple Pay和iCloud等功能的人才需要加入付费开发者计划。）。\n然后，在 shell 中执行如下操作：\nxcode-select --install\n或者，你可以从 Xcode from the Mac App Store 安装最新版本的完整的 Xcode。 这会包含许多您不需要的东西，但是它有 App Store 便利性的优势。\n\n2.3.3 Linux\n请确保你不仅已经安装了 R，还安装了 R 开发工具 (R development tools)。 例如，在 Ubuntu（以及 Debian）上，你需要安装 r-base-dev 包：\nsudo apt install r-base-dev\n在 Fedora 和 RedHat 上，开发工具（名为 R-core-devel）将会在你使用 sudo dnf install R 时自动安装。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>系统设置</span>"
    ]
  },
  {
    "objectID": "setup.html#验证系统设置",
    "href": "setup.html#验证系统设置",
    "title": "2  系统设置",
    "section": "\n2.4 验证系统设置",
    "text": "2.4 验证系统设置\n你可以使用 devtools::dev_sitrep() 生成一个“（软件包）开发环境报告”：\n\ndevtools::dev_sitrep()\n#&gt; ── R ───────────────────────────────────────────────────────────────────────\n#&gt; • version: 4.1.2\n#&gt; • path: '/Library/Frameworks/R.framework/Versions/4.1/Resources/'\n#&gt; ── RStudio ─────────────────────────────────────────────────────────────────\n#&gt; • version: 2022.2.0.443\n#&gt; ── devtools ────────────────────────────────────────────────────────────────\n#&gt; • version: 2.4.3.9000\n#&gt; • devtools or its dependencies out of date:\n#&gt;   'gitcreds', 'gh'\n#&gt;   Update them with `devtools::update_packages(\"devtools\")`\n#&gt; ── dev package ─────────────────────────────────────────────────────────────\n#&gt; • package: 'rpkgs'\n#&gt; • path: '/Users/jenny/rrr/r-pkgs/'\n#&gt; • rpkgs dependencies out of date:\n#&gt;   'gitcreds', 'generics', 'tidyselect', 'dplyr', 'tidyr', 'broom', 'gh'\n#&gt;  Update them with `devtools::install_dev_deps()`\n\n如果它揭示了某些工具或软件包丢失或过时的情况，那么我们鼓励你进行相应的更新。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>系统设置</span>"
    ]
  },
  {
    "objectID": "setup.html#footnotes",
    "href": "setup.html#footnotes",
    "title": "2  系统设置",
    "section": "",
    "text": "在写作本书时，devtools 提供了来自 remotes, pkgbuild, pkgload, rcmdcheck, revdepcheck, sessioninfo, usethis, testthat, and roxygen2 的功能↩︎\n译者注：R 中导入软件包的实质是载入其命名空间并将它添加到搜索列表中。↩︎\n这是我们推荐使用 require() 而非 library() 的少数情况之一。如果 library() 无法附加软件包，它将失败报错，从而终止执行你的 .Rprofile 文件。 如果 require() 无法附加软件包，它将会发出警告但仍然允许你的 .Rprofile 继续执行。 这将在 ?sec-dependencies-attach-vs-load 中进一步讨论。↩︎",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>系统设置</span>"
    ]
  },
  {
    "objectID": "structure.html",
    "href": "structure.html",
    "title": "3  软件包结构与状态",
    "section": "",
    "text": "3.1 软件包状态\n当你创建或修改软件包时，需要在它的“源代码”或“源文件”上进行。 你会以源代码的形式和正在开发中的包进行交互。 当然，这并不是你在日常使用中最熟悉的软件包形式。 但是，如果你了解 R 包可能处于的五种状态，那么软件包开发工作流将变得更有意义：\n你可能已经了解一些将软件包置于这些状态的函数。 例如，install.packages() 函数可以将软件包从源代码状态、打包状态或二进制文件状态转为已安装状态。 devtools::install_github() 函数获取 GitHub 上的源代码软件包并将其转为已安装状态。 而 library() 函数将已安装的软件包加载到内存中，使其立即可以直接使用。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-package-states",
    "href": "structure.html#sec-package-states",
    "title": "3  软件包结构与状态",
    "section": "",
    "text": "源代码状态 (source)\n打包状态 (bundled)\n二进制文件状态 (binary)\n已安装状态 (installed)\n载入内存状态 (in-memory)",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-source-package",
    "href": "structure.html#sec-source-package",
    "title": "3  软件包结构与状态",
    "section": "\n3.2 源码包 (Source Package)",
    "text": "3.2 源码包 (Source Package)\n一个源代码软件包就是一个有着特定结构的文件目录。 它包含特定的组件，例如一个 DESCRIPTION 文件，包含 .R 文件的 R/ 目录等等。 本书其余的大部分章节都致力于详细介绍这些组件。\n如果你刚刚接触 R 包开发，那么你可能从未见过源代码形式的软件包！ 你的计算机上甚至可能没有任何源码包。 以源代码形式查看软件包的最简单的方法是在网站上浏览其代码。\n许多 R 包是在 GitHub（或者 GitLab 以及类似的平台）上公开开发的。 要找到它们的网址，最好的情况是你能够访问软件包的 CRAN 主页 (landing page)，例如：\n\nforcats: https://cran.r-project.org/package=forcats\n\nreadxl: https://cran.r-project.org/package=readxl\n\n\n页面中一个 URL 会链接到公共托管服务上的存储库，例如：\n\nforcats: https://github.com/tidyverse/forcats\n\nreadxl: https://github.com/tidyverse/readxl\n\n\n即使这个包是在公共存储库中开发的，有时候一些维护者会忘记列出这个 URL，但是你仍然可以通过搜索发现它。\n即使软件包不是在公共平台上开发的，你也可以通过 由 R-hub 维护的非官方只读镜像 来访问其源代码，例如：\n\nMASS: https://github.com/cran/MASS\n\ncar: https://github.com/cran/car\n\n\n请注意，在 cran GitHub 组织中探索软件包的源代码及其开发历史并不等同于探索软件包真正的开发场所，因为里面的源代码和演变历史只是根据它在 CRAN 的正式发布版本 (release) 中通过逆向工程提取出来的。 我们看到的这只是对软件包及其开发历史的一种编辑结果，但根据定义，它仍然包含了所有必需的内容。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-bundled-package",
    "href": "structure.html#sec-bundled-package",
    "title": "3  软件包结构与状态",
    "section": "\n3.3 归档包 (Bundled Package)1\n",
    "text": "3.3 归档包 (Bundled Package)1\n\n一个归档打包的软件包是被压缩成单个文件的软件包。 按照惯例（该惯例来自 Linux），R 中的归档包使用 .tar.gz 扩展名，有时候也被称为 “source tarballs”。 这意味着多个文件已经被打包为一个文件 (.tar) 并使用 gzip (.gz) 进行压缩。 虽然归档包本身并不那么有用，但它是源码包和已安装包之间平台无关、便于传输的中间媒介。\n在从本地开发的软件包中生成归档包这种罕见的情况下，请使用 devtools::build() 函数。 在幕后，它会调用 pkgbuild::build() 并最终调用 R CMD build，这些内容会在 Writing R Extensions 的 Building package tarballs 章节中进行更多阐述。\n这应该会提醒你，归档包或 “source tarball” 不仅仅是对源文件进行 tar 打包归档，然后使用 gzip 压缩的结果。 按照惯例，在 R 世界中，在制作 .tar.gz 文件时还要执行一些操作，而这就是为什么我们选择在本书中将这种形式称为归档包的原因。\n每一个 CRAN 软件包都以归档包的形式提供，可以通过软件包主页 (landing page) 中 “Package source” 字段获取。 继续我们上面的示例，你可以下载归档包 forcats_0.4.0.tar.gz 和 readxl_1.3.1.tar.gz（或者任何当前的版本）。 你可以在 shell（而不是 R 控制台）中进行解压：\ntar xvf forcats_0.4.0.tar.gz\n如果解压一个归档包，你会发现它看起来几乎与源码包相同。 Figure 3.1 展示了一个名为 zzzpackage 的虚构软件包的源码包、归档包和二进制包中的文件。 我们精心设计了这个示例，以包含本书中涉及的大部分软件包组件。 不过，不是每个软件包都包含这里看到的每个文件，这个图也不包括包中可能出现的每个文件。\n\n\n\n\n\n\n\nFigure 3.1: 软件包形式：源代码 vs. 归档 vs. 二进制。\n\n\n\n\n未压缩的归档包相比于源码包的主要区别为：\n\n已经构建了主题文档 (vignettes)，因此渲染好的输出文件，例如 HTML 会出现在 inst/doc/ 目录下，并且主题文档 (vignette) 索引会出现在 build/ 目录中。\n本地源码包可能包含用于在开发期间节省时间的临时文件，例如 src/ 中的编译产物 (compilation artifacts)。 这些文件不会在归档包中出现。\n.Rbuildignore 中列出的任何文件都不包含在捆绑包中。 这些文件通常有助于你的开发过程，但应该从分发的最终产品中排除。\n\n\n3.3.1 .Rbuildignore\n\n你不需要经常考虑 .tar.gz 形式的软件包的确切结构，但你确实需要了解 .Rbuildignore 文件。 它决定了源码包中的哪些文件可以进入后面的工作流。\n.Rbuildignore 的每一行都是一个 Perl 兼容的正则表达式 (Perl-compatible regular expression, PCRE)，它会在不考虑大小写的情况下与源码包中每个文件的路径进行匹配2。 如果正则表达式匹配到了文件或目录，那么该文件或目录将会被排除，无法进入之后的软件包开发工作流。 注意，有一些默认排除项由 R 本身执行，主要与经典的版本控制系统和编辑器（例如 SVN, Git 和 Emacs）有关。\n我们通常使用 usethis::use_build_ignore() 函数来修改 .Rbuildignore，该函数能够帮助你处理一些容易遗忘的细节，例如正则表达式的添加定位锚点 (anchoring) 和转义 (escaping)。 要排除特定的文件或目录（这是最常见的用例），必须为正则表达式添加定位锚点 (anchor)。 例如，如果要排除一个名为 “notes” 的目录，.Rbuildignore 中对应条目必须是 ^notes$，而没有添加定位锚点的正则表达式 notes 将会匹配任意包含 “notes” 的文件名，例如 R/notes.R, man/important-notes.R, data/endnotes.Rdata 等。 我们发现 use_build_ignore() 有助于我们第一次就更准确地获取更多的 .Rbuildignore 条目。\n.Rbuildignore 提供了一种解决方式，能够协调支持开发流程的常规做法和 CRAN 对软件包提交和分发的要求之间的一些紧张关系 (?sec-release)。 即使你不打算在 CRAN 上发布你的软件包，遵循这些约定也能让你充分地利用 R 的内置工具来检查和安装程序包。 你应该添加到 .Rbuildignore 中的文件分为两个半重叠的类别：\n\n帮助你以编程方式生成软件包内容的文件。例如：\n\n使用 README.Rmd 生成信息丰富且最新的 README.md (?sec-readme)。\n储存用于创建和更新内部或导出数据的 .R 脚本 (?sec-data-data-raw)。\n\n\n在 CRAN 的要求之外驱动软件包开发、检查和文档的文件。例如：\n\n和 RStudio IDE 有关的文件 (Section 4.2)。\n使用 pkgdown package 生成的软件包网站 (?sec-website)。\n与持续集成/部署有关的配置文件 (?sec-sw-dev-practices-ci)。\n\n\n\n以下是一个 .Rbuildignore 文件非详尽的典型条目列表，来自 tidyverse 包：\n^.*\\.Rproj$         # 指定目录为 RStudio 项目的文件\n^\\.Rproj\\.user$     # RStudio 使用的临时文件\n^README\\.Rmd$       # 用于生成 README.md 的 Rmd 文件\n^LICENSE\\.md$       # 许可证全文\n^cran-comments\\.md$ # CRAN 提交的评论意见\n^data-raw$          # 用于创建软件包中包含的数据的代码\n^pkgdown$           # 用于软件包网站的资源文件\n^_pkgdown\\.yml$     # 软件包网站的配置文件\n^\\.github$          # GitHub Actions 工作流\n注意，上面的注释不能出现在实际的 .Rbuildignore 文件中，它们在这里只是为了说明文件作用。\n当你需要向 .Rbuildignore 中添加文件时，我们会在书中提到。 请记住 usethis::use_build_ignore() 是管理这类文件的一种有吸引力的方法。 此外，许多 usethis 函数在添加一个应该列在 .Rbuildignore 中的文件时会自动处理这个问题。 例如 use_readme_rmd() 会将 “^README\\.Rmd$” 添加到 .Rbuildignore。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-structure-binary",
    "href": "structure.html#sec-structure-binary",
    "title": "3  软件包结构与状态",
    "section": "\n3.4 二进制包 (Binary Package)",
    "text": "3.4 二进制包 (Binary Package)\n如果你想把你的包分发给没有软件包开发工具的用户，则需要提供二进制包文件。 二进制包最主要的制作者和分发者是 CRAN，而不是单个维护者。 但是，即使你将分发包的责任委托给 CRAN，对于维护人员来说，理解二进制包的性质仍然很重要。\n像一个捆绑包一样，一个二进制包是一个单独的文件。 但是与捆绑包不同，二进制包是特定于平台的，有两种基本类型：Windows 和 macOS。 （Linux 用户通常需要拥有从 .tar.gz 文件安装软件包所必须的工具，尽管 Posit Public Package Manager 等资源的出现使得 Linux 用户能够像 Windows 和 macOS 用户一样访问并从二进制包安装。）\nmacOS 上的二进制包是以 .tgz 为后缀的文件，而 Windows 上的二进制包则以 .zip 作为文件后缀。 如果你需要制作一个二进制包，则需要在相关的平台上使用 devtools::build(binary = TRUE)。 在幕后，该函数调用 pkgbuild::build(binary= TRUE) 并且最终调用 R CMD INSTALL --build，这一命令会在 Writing R Extensions 中的 Building binary packages 进行更详细的叙述。 如果你选择在 CRAN 上发布你的软件包 (?sec-release)，你需要以归档包的形式提交软件包，然后 CRAN 会创建并分发包二进制包文件。\nCRAN 软件包通常以二进制形式提供，适用于 macOS 和 Windows，且适用于 R 的当前、历史和（可能的）开发版本。 继续上面的例子，你可以下载如下所示的二进制包：\n\nmacOS 上的 forcats：forcats_0.4.0.tgz\n\nWindows 上的 readxl：readxl_1.3.1.zip\n\n\n实际上，当你调用 install.packages() 时，这就是在幕后通常会发生的一部分事情。\n如果你解压一个二进制包，你会看到其内部结构和源码包或归档包非常不同。 Figure 3.1 包含了二者的比较，所以现在是重温这个图的好时机。 以下是一些最显著的区别：\n\nR/ 目录下不再有 .R 文件，而是有三个文件以高效的文件格式存储着解析后的函数。 这基本上是加载所有R代码然后用 save() 保存函数的结果。 （在此过程中会添加一些额外的元数据，以使函数加载过程尽可能快）。\n一个 Meta/ 目录中包含一些 .rds 文件。 这些文件中包含关于软件包的缓存元数据，例如帮助文档涵盖的主题以及 DESCRIPTION 文件的解析版本。 （你可以使用 readRDS() 来查看这些文件中的确切内容）。 这些文件通过缓存昂贵的计算结果使软件包加载过程更快。\n实际的帮助内容出现在 help/ 和 html/ 中（不再出现在 man/ 中）。\n如果 src/ 目录下有任何代码，那么现在会有一个 libs/ 目录，其中包含代码编译后的结果。\n如果 data/ 目录下有任何数据对象，它们现在已经被转换为更高效的数据格式。\ninst/ 目录下的内容被移动到顶层目录， 例如，主题文档 (vignette) 文件现在在 doc/ 目录下。\n一些文件和文件夹被删除了，例如 README.md、build/、tests/ 和 vignettes/。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-installed-package",
    "href": "structure.html#sec-installed-package",
    "title": "3  软件包结构与状态",
    "section": "\n3.5 已安装的包 (Installed package)",
    "text": "3.5 已安装的包 (Installed package)\n一个已安装的软件包是一个二进制包，它被解压缩到一个软件包库中（在 Section 3.7 中进行了叙述）。 Figure 3.2 说明了安装包的多种方式，以及将软件包从一个状态转换为另一个状态的一些函数。 这个图表很复杂！ 在理想情况下，安装一个软件包需要将一组简单步骤串在一起：source -&gt; bundle, bundle -&gt; binary, binary -&gt; installed。 然而在现实世界中，事情并没有那么简单，因为通常有（更快的）捷径可用。\n\n\n\n\n\n\n\nFigure 3.2: 转换软件包状态的许多方法。\n\n\n\n\n内置命令行工具 R CMD INSTALL 能够进行所有类型软件包的安装。 它可以从源文件、归档包（也称为 source tarball）或者二进制包进行安装。 要了解更多详细信息，请参阅 R Installation and Administration 中的 Installing packages section。 与 devtools::build() 一样，devtools 提供了一个封装函数 devtools::install()，能够使 R CMD INSTALL 在 R session 中可用。\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio 可以通过 Build 窗格中的 Install 和 More 下拉菜单和 Build 菜单中的 Install Package 来帮助你安装你正在开发中的软件包。\n\n\n可以理解的是，大多数用户喜欢在舒适的 R session 中直接从 CRAN 安装包。 内置函数 install.packages() 满足了这一需求。 它可以下载各种形式的包，安装它，并可选地处理依赖项的安装。\n然而，从 R session 中安装 R 包的便利性是有代价的。 正如你所预料的那样，重新安装当前 session 中正在使用的包可能会有点困难。 实际上 install.packages() 在大多数情况下都是有效的，但有时不行，特别是在 Windows 上安装带有编译代码的 R 包时。 由于 Windows 上的文件句柄是锁定的，尝试安装正在使用的软件包的新版本可能会导致安装损坏，其中软件包的 R 代码已经更新，但其编译代码没有更新。 在进行故障排除时，Windows 用户应该努力在一个干净的 R session 中安装软件包，并加载尽可能少的软件包。\npak 软件包 (https://pak.r-lib.org/) 是一个相对较新的包（在本书写作时），它提供了一个很有前途的 install.packages() 的替代方案，另外还有其它更专业的函数可以替代，例如 devtools::install_github()。 现在就全面推荐使用 pak 来满足你素有的软件包安装需求还为时过早，但是我们肯定会在个人工作流程中越来越多地使用它。 pak 的旗舰功能之一是它很好地解决了上面描述的 “locked DLL” 问题，即在 Windows 上用编译后的代码进行软件包更新。 当你更加深入地了解软件包开发时，你会发现自己在完成一套全新的任务，例如从开发分支中安装依赖项，或仔细检查包依赖树。 pak 为此和许多其它相关任务提供了一个丰富的工具包。 我们预测，pak 将很快成为我们如何安装软件包（以及更多任务）的官方建议。\n然而，在此期间，我们先来描述现状。 devtools 长期以来提供了一系列 install_*() 函数来解决 install.packages() 无法满足的一些需求，或者使现有功能更加容易使用。 这些函数实际上保存在 remotes 软件包 中，并由 devtools 重新导出供使用。 （考虑到我们上面所说的，remotes 包很可能会被取代，取而代之的是 pak 包，但我们还没有完全做到这一点。）\n\nlibrary(remotes)\n\nfuns &lt;- as.character(lsf.str(\"package:remotes\"))\ngrep(\"^install_.+\", funs, value = TRUE)\n#&gt;  [1] \"install_bioc\"      \"install_bitbucket\" \"install_cran\"     \n#&gt;  [4] \"install_deps\"      \"install_dev\"       \"install_git\"      \n#&gt;  [7] \"install_github\"    \"install_gitlab\"    \"install_local\"    \n#&gt; [10] \"install_remote\"    \"install_svn\"       \"install_url\"      \n#&gt; [13] \"install_version\"\n\ninstall_github() 是这些函数中最有用的，也在 Figure 3.2 中列出了。 它是一系列函数的旗舰示例，这些函数可以从非 CRAN 的远程位置下载包，并执行安装包及其依赖项所需的任何操作。 devtools/remotes 的其余 install_*() 函数旨在使那些能够通过基础工具在技术上实现的事情变得更加简单或明确，例如 install_version()，它安装特定版本的 CRAN 软件包。\n类似于在 Section 3.3.1 中描述的 .Rbuildignore，.Rinstignore 允许你将文件保存在归档包中，但是不保存在已安装的包中。 然而，和 .Rbuildignore 相比，这一功能是相当模糊且很少使用的。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#内存中的包-in-memory-package",
    "href": "structure.html#内存中的包-in-memory-package",
    "title": "3  软件包结构与状态",
    "section": "\n3.6 内存中的包 (In-memory package)",
    "text": "3.6 内存中的包 (In-memory package)\n我们终于讲到了一个每个使用 R 的人都熟悉的命令：\n\nlibrary(usethis)\n\n假设你已经安装了 usethis，这个函数调用会使得 usethis 包的所有函数都能够使用，也就是说，我们现在可以直接执行函数：\n\ncreate_package(\"/path/to/my/coolpackage\")\n\nusethis 包现在已经被载入了内存，实际上，它也被附加到了搜索路径中。 在编写脚本时，载入和附加软件包之间的区别并不重要，但是当你编写软件包时却非常重要。 你将在 ?sec-dependencies-attach-vs-load 中了解到它们之间的区别和重要性。\nlibrary() 并不是迭代地调整和测试驱动一个软件包的好方法，因为它只对已安装的包起作用。 在 Section 4.4 中你将会了解到 devtools::load_all() 是如何通过允许你直接将源码包加载到内存中来加速开发的。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-library",
    "href": "structure.html#sec-library",
    "title": "3  软件包结构与状态",
    "section": "\n3.7 软件包库 (Package libraries)",
    "text": "3.7 软件包库 (Package libraries)\n我们刚刚讨论了 library() 函数，它的名称源于其功能。 当你调用 library(somepackage) 时，R 会在当前的所有库中查找一个叫做“somepackage”的已安装包，如果查找成功，R 会使得 somepackage 包变得可用。\n在 R 中，一个库就是一个包含了许多已安装软件包的目录，有点像藏书的图书馆。 不幸的是，在 R 的世界，我们会经常遇到“库 (library)”和“包 (package)”这两个词的混淆用法。 例如，delyr 实际上是一个包 (package)，但是也有人通常将其称为一个库 (library) 造成这种混乱的原因有几个。 首先，R 的术语有争议地违背了更广泛的编程惯例，“库 (library)”的通常含义更接近于我们所说的“包 (package)”。 library() 函数的名称可能会强化这一错误的关联。 最后，这种词汇错误通常是无害的，因此 R 用户很容易养成错误的习惯，然而指出这个错误的人会看起来像是令人无法忍受的学究。 但是最重要的事实是：\n\n我们使用 library() 函数来加载3一个软件包。\n\n当你参与软件包开发中时，这两者的区别时重要且有用的。\n你的计算机上可以有多个库。 事实上，你们中的很多人已经这样做了，尤其是 Windows 用户。 你可以使用 .libPaths() 来查看当前处于活动状态的库。 以下是在 Windows 中该函数的输出结果：\n\n# on Windows\n.libPaths()\n#&gt; [1] \"C:/Users/jenny/Documents/R/win-library/4.2\"\n#&gt; [2] \"C:/Program Files/R/R-4.2.2/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#&gt; [[1]]\n#&gt;   [1] \"abc\"           \"anytime\"       \"askpass\"       \"assertthat\"   \n#&gt;  ...\n#&gt; [145] \"zeallot\"      \n#&gt; \n#&gt; [[2]]\n#&gt;  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#&gt;  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#&gt;  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#&gt; [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#&gt; [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#&gt; [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#&gt; [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#&gt; [29] \"translations\" \"utils\"\n\n以下是在 macOS 中的表现（你的输出内容可能有所不同）：\n\n# on macOS\n.libPaths()\n#&gt; [1] \"/Users/jenny/Library/R/arm64/4.2/library\"\n#&gt; [2] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#&gt; [[1]]\n#&gt;    [1] \"abc\"                  \"abc.data\"             \"abind\"                \n#&gt;  ...\n#&gt; [1033] \"Zelig\"                \"zip\"                  \"zoo\"                 \n#&gt; \n#&gt; [[2]]\n#&gt;  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#&gt;  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#&gt;  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#&gt; [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#&gt; [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#&gt; [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#&gt; [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#&gt; [29] \"translations\" \"utils\"\n\n在这两种情况下，我们都看到了两个活动的库，查询顺序如下：\n\n用户库\n系统级或全局级的库\n\n这样的设置在 Windows 中是典型设置，但在 macOS 和 Linux 上通常需要手动配置4。 在该设置下，从 CRAN（或其它源）或本地开发中安装的附加软件包会被保存到用户库中。 和上面一样，macOS 系统是我们主要的开发机器，并且安装了很多软件包（大约 1000 个），而 Windows 系统只是偶尔会被使用，而且要简朴得多。 R 附带的基础和推荐软件包的核心集合位于系统级库中，这一点在所有操作系统上是相同的。 这种分离对许多开发人员来说很有吸引力，例如能够使得清理附加软件包变得更容易，且不会干扰 base R 的安装。\n如果你使用 macOS 或 Linux，并且只看到了一个库，你不需要紧急更改任何内容。 但是下次升级 R 时，请考虑创建一个用户级库。 默认情况下，R 会在环境变量 R_LIBS_USER 存储的路径中查找用户库路径，在 macOS 中该环境变量默认为 ~/Library/R/m/x.y/library,，而在 Linux 中则默认是 ~/R/m-library/x.y（其中 m 是对 CPU 架构的简明描述，而 x.y 是 R 版本号）。 你可以通过 Sys.getenv(\"R_LIBS_USER\") 来查看当前的用户库路径。 默认情况下，这些目录不存在，必须通过创建目录来启用它们。 当你安装一个新版本的 R 时，在安装任何软件包之前，请使用 dir.create(Sys.getenv(\"R_LIBS_USER\"), recursive = TRUE) 在默认位置上创建一个用户库。 现在，你将拥有如上所示的库设置。 或者，你也可以在其它任何地方设置一个用户库，并通过在 .Renviron 中设置 R_LIBS_USER 环境变量来告诉 R 用户库的位置。 编辑你的 .Renviron 文件的最简单方法是使用 usethis::edit_r_environ()，如果文件不存在，这一函数将会创建该文件，并打开它进行编辑。\n这些库的文件路径也清楚地表明它们与特定版本的 R（在本书写作时是 4.2.x）相关联，这是常见的情况。 这一特点反映并强调了这样一个事实，当你将 R 从 4.1 更新到 4.2 ，即在次要版本号上进行更新时，你需要重新安装软件包。 对于在补丁版本号上的更新，例如从 4.2.1 更新到 4.2.2 时，通常不需要重新安装软件包。\n随着你开始越来越精密和复杂地使用 R，开始更有目的地管理软件包库是很正常的。 例如，像 renv（以及它的前身 packrat）这样的工具能够自动化管理特定于项目的库。 这对于使数据产品具有可复制性、可移植性和相互隔离性来说十分重要。 软件包开发者可能会在库搜索路径前添加一个临时库，其中包含一组特定版本的包，以便在不影响其它日常工作的情况下探索向后和向前兼容性问题。 反向依赖检查 (Reverse dependency checks) 是我们显式管理库搜索路径的另一个例子。\n以下是按范围和持久性排序的一些主要开关，用于控制哪些库处于活动状态：\n\n环境变量，例如 R_LIBS 和 R_LIBS_USER，它们在 R 启动时被查询；\n调用 .libPaths() 时传入一个或多个文件路径作为库路径；\n通过 withr::with_libpaths() 使用临时更改的库搜索路径执行小段代码；\n函数的参数，例如 install.packages(lib =) 以及 library(lib.loc =)。\n\n最后，重要的是要注意 library() 永远不应该在软件包内使用。 软件包和脚本依赖于不同的机制来声明它们的依赖关系，这是你需要在心智模型和习惯中做出的最大调整之一。 我们会在 ?sec-description-imports-suggests 和 ?sec-dependencies-in-practice 中详细讨论这一主题。",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "structure.html#footnotes",
    "href": "structure.html#footnotes",
    "title": "3  软件包结构与状态",
    "section": "",
    "text": "译者注：“归档”一词在中国大陆的用语习惯中较少使用，但考虑 tar 的原意，确实有“为一个版本创建只读快照”的含义，和这里的 R 包相符。↩︎\n要查看会参与匹配的所有文件路径的集合，请在软件包的顶层目录执行命令 dir(full.names = TRUE, recursive = TRUE, include.dirs = TRUE, all.files = TRUE)。↩︎\n好吧，实际上 library() 会加载并附加一个软件包，不过这是 ?sec-dependencies-attach-vs-load 的主题。↩︎\n如果想知道更多的详细信息，请参阅 What They Forgot To Teach You About R 中的 Maintaining R section, R Installation and Administration 中的 Managing Libraries 以及使用 ?Startup 和 ?.libPaths 查看 R 的帮助文档。↩︎",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>软件包结构与状态</span>"
    ]
  },
  {
    "objectID": "workflow101.html",
    "href": "workflow101.html",
    "title": "4  基本开发工作流",
    "section": "",
    "text": "4.1 创建一个软件包",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-create-package",
    "href": "workflow101.html#sec-workflow101-create-package",
    "title": "4  基本开发工作流",
    "section": "",
    "text": "4.1.1 调查已经存在的软件包\nMany packages are born out of one person’s frustration at some common task that should be easier. How should you decide whether something is package-worthy? There’s no definitive answer, but it’s helpful to appreciate at least two types of payoff:\n\nProduct: your life will be better when this functionality is implemented formally, in a package.\nProcess: greater mastery of R will make you more effective in your work.\n\nIf all you care about is the existence of a product, then your mdiaoal is to navigate the space of existing packages. Silge, Nash, and Graves organized a survey and sessions around this at useR! 2017 and their write up for the R Journal (Silge, Nash, and Graves 2018) provides a comprehensive roundup of resources.\nIf you are looking for ways to increase your R mastery, you should still educate yourself about the landscape. But there are plenty of good reasons to make your own package, even if there is relevant prior work. The way experts got that way is by actually building things, often very basic things, and you deserve the same chance to learn by tinkering. If you’re only allowed to work on things that have never been touched, you’re likely looking at problems that are either very obscure or very difficult.\nIt’s also valid to evaluate the suitability of existing tools on the basis of user interface, defaults, and edge case behaviour. A package may technically do what you need, but perhaps it’s very unergonomic for your use case. In this case, it may make sense for you to develop your own implementation or to write wrapper functions that smooth over the sharp edges.\nIf your work falls into a well-defined domain, educate yourself about the existing R packages, even if you’ve resolved to create your own package. Do they follow specific design patterns? Are there specific data structures that are common as the primary input and output? For example, there is a very active R community around spatial data analysis (r-spatial.org) that has successfully self-organised to promote greater consistency across packages with different maintainers. In modeling, the hardhat package provides scaffolding for creating a modeling package that plays well with the tidymodels ecosystem. Your package will get more usage and will need less documentation if it fits nicely into the surrounding landscape.\n\n4.1.2 为你的软件包取名\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.”\n— Phil Karlton\n\nBefore you can create your package, you need to come up with a name for it. This can be the hardest part of creating a package! (Not least because no one can automate it for you.)\n\n4.1.2.1 正式要求\nThere are three formal requirements:\n\nThe name can only consist of letters, numbers, and periods, i.e., ..\nIt must start with a letter.\nIt cannot end with a period.\n\nUnfortunately, this means you can’t use either hyphens or underscores, i.e., - or _, in your package name. We recommend against using periods in package names, due to confusing associations with file extensions and S3 methods.\n\n4.1.2.2 需要考虑的事情\nIf you plan to share your package with others, it’s important to come up with a good name. Here are some tips:\n\nPick a unique name that’s easy to Google. This makes it easy for potential users to find your package (and associated resources) and for you to see who’s using it.\n\nDon’t pick a name that’s already in use on CRAN or Bioconductor. You may also want to consider some other types of name collision:\n\nIs there an in-development package maturing on, say, GitHub that already has some history and seems to be heading towards release?\nIs this name already used for another piece of software or for a library or framework in, e.g., the Python or JavaScript ecosystem?\n\n\nAvoid using both upper and lower case letters: doing so makes the package name hard to type and even harder to remember. For example, it’s hard to remember if it’s Rgtk2 or RGTK2 or RGtk2.\nGive preference to names that are pronounceable, so people are comfortable talking about your package and have a way to hear it inside their head.\n\nFind a word that evokes the problem and modify it so that it’s unique. Here are some examples:\n\nlubridate makes dates and times easier.\nrvest “harvests” the content from web pages.\nr2d3 provides utilities for working with D3 visualizations.\nforcats is an anagram of factors, which we use for categorical data.\n\n\n\nUse abbreviations, like the following:\n\nRcpp = R + C++ (plus plus)\nbrms = Bayesian Regression Models using Stan\n\n\n\nAdd an extra R, for example:\n\nstringr provides string tools.\nbeepr plays notification sounds.\ncallr calls R, from R.\n\n\n\nDon’t get sued.\n\nIf you’re creating a package that talks to a commercial service, check the branding guidelines. For example, rDrop isn’t called rDropbox because Dropbox prohibits any applications from using the full trademarked name.\n\n\n\nNick Tierney presents a fun typology of package names in his Naming Things blog post, which also includes more inspiring examples. He also has some experience with renaming packages; the post So, you’ve decided to change your r package name is a good resource if you don’t get this right the first time.\n\n4.1.2.3 使用 available 包\nIt is impossible to abide by all of the above suggestions simultaneously, so you will need to make some trade-offs. The available package has a function called available() that helps you evaluate a potential package name from many angles:\n\nlibrary(available)\n\navailable(\"doofus\")\n#&gt; Urban Dictionary can contain potentially offensive results,\n#&gt;   should they be included? [Y]es / [N]o:\n#&gt; 1: 1\n#&gt; ── doofus ──────────────────────────────────────────────────────────────────\n#&gt; Name valid: ✔\n#&gt; Available on CRAN: ✔ \n#&gt; Available on Bioconductor: ✔\n#&gt; Available on GitHub:  ✔ \n#&gt; Abbreviations: http://www.abbreviations.com/doofus\n#&gt; Wikipedia: https://en.wikipedia.org/wiki/doofus\n#&gt; Wiktionary: https://en.wiktionary.org/wiki/doofus\n#&gt; Sentiment:???\n\navailable::available() does the following:\n\nChecks for validity.\nChecks availability on CRAN, Bioconductor, and beyond.\nSearches various websites to help you discover any unintended meanings. In an interactive session, the URLs you see above are opened in browser tabs.\nAttempts to report whether name has positive or negative sentiment.\n\npak::pkg_name_check() is alternative function with a similar purpose. Since the pak package is under more active development than available, it may emerge as the better option going forward.\n\n4.1.3 软件包项目的创建\nOnce you’ve come up with a name, there are two ways to create the package.\n\nCall usethis::create_package().\nIn RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\nThis produces the smallest possible working package, with three components:\n\nAn R/ directory, which you’ll learn about in ?sec-r.\nA basic DESCRIPTION file, which you’ll learn about in ?sec-description.\nA basic NAMESPACE file, which you’ll learn about in ?sec-dependencies-NAMESPACE-file.\n\nIt may also include an RStudio project file, pkgname.Rproj, that makes your package easy to use with RStudio, as described below. Basic .Rbuildignore and .gitignore files are also left behind.\n\n\n\n\n\n\nWarning\n\n\n\nDon’t use package.skeleton() to create a package. Because this function comes with R, you might be tempted to use it, but it creates a package that immediately throws errors with R CMD build. It anticipates a different development process than we use here, so repairing this broken initial state just makes unnecessary work for people who use devtools (and, especially, roxygen2). Use create_package().\n\n\n\n4.1.4 你应该在哪里执行 create_package()？\nThe main and only required argument to create_package() is the path where your new package will live:\n\ncreate_package(\"path/to/package/pkgname\")\n\nRemember that this is where your package lives in its source form (Section 3.2), not in its installed form (Section 3.5). Installed packages live in a library and we discussed conventional setups for libraries in Section 3.7.\nWhere should you keep source packages? The main principle is that this location should be distinct from where installed packages live. In the absence of external considerations, a typical user should designate a directory inside their home directory for R (source) packages. We discussed this with colleagues and the source of many tidyverse packages lives inside directories like ~/rrr/, ~/documents/tidyverse/, ~/r/packages/, or ~/pkg/. Some of us use one directory for this, others divide source packages among a few directories based on their development role (contributor vs. not), GitHub organization (tidyverse vs r-lib), development stage (active vs. not), and so on.\nThe above probably reflects that we are primarily tool-builders. An academic researcher might organize their files around individual publications, whereas a data scientist might organize around data products and reports. There is no particular technical or traditional reason for one specific approach. As long as you keep a clear distinction between source and installed packages, just pick a strategy that works within your overall system for file organization, and use it consistently.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-rstudio-projects",
    "href": "workflow101.html#sec-workflow101-rstudio-projects",
    "title": "4  基本开发工作流",
    "section": "\n4.2 RStudio 项目",
    "text": "4.2 RStudio 项目\ndevtools works hand-in-hand with RStudio, which we believe is the best development environment for most R users. To be clear, you can use devtools without using RStudio and you can develop packages in RStudio without using devtools. But there is a special, two-way relationship that makes it very rewarding to use devtools and RStudio together.\n\n\n\n\n\n\nRStudio\n\n\n\nAn RStudio Project, with a capital “P”, is a regular directory on your computer that includes some (mostly hidden) RStudio infrastructure to facilitate your work on one or more projects, with a lowercase “p”. A project might be an R package, a data analysis, a Shiny app, a book, a blog, etc.\n\n\n\n4.2.1 使用 RStudio 项目的好处\nFrom Section 3.2, you already know that a source package lives in a directory on your computer. We strongly recommend that each source package is also an RStudio Project. Here are some of the payoffs:\n\nProjects are very “launch-able”. It’s easy to fire up a fresh instance of RStudio in a Project, with the file browser and working directory set exactly the way you need, ready for work.\n\nEach Project is isolated; code run in one Project does not affect any other Project.\n\nYou can have several RStudio Projects open at once and code executed in Project A does not have any effect on the R session and workspace of Project B.\n\n\nYou get handy code navigation tools like F2 to jump to a function definition and Ctrl + . to look up functions or files by name.\n\nYou get useful keyboard shortcuts and a clickable interface for common package development tasks, like generating documentation, running tests, or checking the entire package.\n\n\n\n\n\n\n\nFigure 4.1: Keyboard Shortcut Quick Reference in RStudio.\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nTo see the most useful keyboard shortcuts, press Alt + Shift + K or use Help &gt; Keyboard Shortcuts Help. You should see something like Figure 4.1.\nRStudio also provides the Command Palette which gives fast, searchable access to all of the IDE’s commands – especially helpful when you can’t remember a particular keyboard shortcut. It is invoked via Ctrl + Shift + P (Windows & Linux) or Cmd + Shift + P (macOS).\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nFollow @rstudiotips on Twitter for a regular dose of RStudio tips and tricks.\n\n\n\n4.2.2 怎样开始一个 RStudio 项目\nIf you follow our recommendation to create new packages with create_package(), each new package will also be an RStudio Project, if you’re working from RStudio.\nIf you need to designate the directory of a pre-existing source package as an RStudio Project, choose one of these options:\n\nIn RStudio, do File &gt; New Project &gt; Existing Directory.\nCall create_package() with the path to the pre-existing R source package.\nCall usethis::use_rstudio(), with the active usethis project set to an existing R package. In practice, this probably means you just need to make sure your working directory is inside the pre-existing package directory.\n\n4.2.3 RStudio 项目文件是什么？\nA directory that is an RStudio Project will contain an .Rproj file. Typically, if the directory is named “foo”, the Project file is foo.Rproj. And if that directory is also an R package, then the package name is usually also “foo”. The path of least resistance is to make all of these names coincide and to NOT nest your package inside a subdirectory inside the Project. If you settle on a different workflow, just know it may feel like you are fighting with the tools.\nAn .Rproj file is just a text file. Here is a representative project file you might see in a Project initiated via usethis:\nVersion: 1.0\n\nRestoreWorkspace: No\nSaveWorkspace: No\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nEncoding: UTF-8\n\nAutoAppendNewline: Yes\nStripTrailingWhitespace: Yes\nLineEndingConversion: Posix\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nYou don’t need to modify this file by hand. Instead, use the interface available via Tools &gt; Project Options (Figure 4.2) or Project Options in the Projects menu in the top-right corner (Figure 4.3).\n\n\n\n\n\n\n\nFigure 4.2: Project Options in RStudio.\n\n\n\n\n\n\n\n\n\n\n\nFigure 4.3: Projects Menu in RStudio.\n\n\n\n\n\n4.2.4 怎样启动一个 RStudio 项目\nDouble-click the foo.Rproj file in macOS’s Finder or Windows Explorer to launch the foo Project in RStudio.\nYou can also launch Projects from within RStudio via File &gt; Open Project (in New Session) or the Projects menu in the top-right corner.\nIf you use a productivity or launcher app, you can probably configure it to do something delightful for .Rproj files. We both use Alfred for this 1, which is macOS only, but similar tools exist for Windows. In fact, this is a very good reason to use a productivity app in the first place.\nIt is very normal – and productive! – to have multiple Projects open at once.\n\n4.2.5 RStudio Project vs. active usethis project\nYou will notice that most usethis functions don’t take a path: they operate on the files in the “active usethis project”. The usethis package assumes that 95% of the time all of these coincide:\n\nThe current RStudio Project, if using RStudio.\nThe active usethis project.\nCurrent working directory for the R process.\n\nIf things seem funky, call proj_sitrep() to get a “situation report”. This will identify peculiar situations and propose ways to get back to a happier state.\n\n# these should usually be the same (or unset)\nproj_sitrep()\n#&gt; *   working_directory: '/Users/jenny/rrr/readxl'\n#&gt; * active_usethis_proj: '/Users/jenny/rrr/readxl'\n#&gt; * active_rstudio_proj: '/Users/jenny/rrr/readxl'",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#working-directory-and-filepath-discipline",
    "href": "workflow101.html#working-directory-and-filepath-discipline",
    "title": "4  基本开发工作流",
    "section": "\n4.3 Working directory and filepath discipline",
    "text": "4.3 Working directory and filepath discipline\nAs you develop your package, you will be executing R code. This will be a mix of workflow calls (e.g., document() or test()) and ad hoc calls that help you write your functions, examples, and tests. We strongly recommend that you keep the top-level of your source package as the working directory of your R process. This will generally happen by default, so this is really a recommendation to avoid development workflows that require you to fiddle with working directory.\nIf you’re totally new to package development, you don’t have much basis for supporting or resisting this proposal. But those with some experience may find this recommendation somewhat upsetting. You may be wondering how you are supposed to express paths when working in subdirectories, such as tests/. As it becomes relevant, we’ll show you how to exploit path-building helpers, such as testthat::test_path(), that determine paths at execution time.\nThe basic idea is that by leaving working directory alone, you are encouraged to write paths that convey intent explicitly (“read foo.csv from the test directory”) instead of implicitly (“read foo.csv from current working directory, which I think is going to be the test directory”). A sure sign of reliance on implicit paths is incessant fiddling with your working directory, because you’re using setwd() to manually fulfill the assumptions that are implicit in your paths.\nUsing explicit paths can design away a whole class of path headaches and makes day-to-day development more pleasant as well. There are two reasons why implicit paths are hard to get right:\n\nRecall the different forms that a package can take during the development cycle (Chapter 3). These states differ from each other in terms of which files and folders exist and their relative positions within the hierarchy. It’s tricky to write relative paths that work across all package states.\nEventually, your package will be processed with built-in tools like R CMD build, R CMD check, and R CMD INSTALL, by you and potentially CRAN. It’s hard to keep track of what the working directory will be at every stage of these processes.\n\nPath helpers like testthat::test_path(), fs::path_package(), and the rprojroot package are extremely useful for building resilient paths that hold up across the whole range of situations that come up during development and usage. Another way to eliminate brittle paths is to be rigorous in your use of proper methods for storing data inside your package (?sec-data) and to target the session temp directory when appropriate, such as for ephemeral testing artefacts (?sec-testing-basics).",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-load-all",
    "href": "workflow101.html#sec-workflow101-load-all",
    "title": "4  基本开发工作流",
    "section": "\n4.4 使用 load_all() 驱动测试",
    "text": "4.4 使用 load_all() 驱动测试\nThe load_all() function is arguably the most important part of the devtools workflow.\n\n# with devtools attached and\n# working directory set to top-level of your source package ...\n\nload_all()\n\n# ... now experiment with the functions in your package\n\nload_all() is the key step in this “lather, rinse, repeat” cycle of package development:\n\nTweak a function definition.\nload_all()\nTry out the change by running a small example or some tests.\n\nWhen you’re new to package development or to devtools, it’s easy to overlook the importance of load_all() and fall into some awkward habits from a data analysis workflow.\n\n4.4.1 使用 load_all() 的好处\nWhen you first start to use a development environment, like RStudio or VS Code, the biggest win is the ability to send lines of code from an .R script for execution in R console. The fluidity of this is what makes it tolerable to follow the best practice of regarding your source code as real 2 (as opposed to objects in the workspace) and saving .R files (as opposed to saving and reloading .Rdata).\nload_all() has the same significance for package development and, ironically, requires that you NOT test drive package code in the same way as script code. load_all() simulates the full blown process for seeing the effect of a source code change, which is clunky enough 3 that you won’t want to do it very often. Figure 4.4 reinforces that the library() function can only load a package that has been installed, whereas load_all() gives a high-fidelity simulation of this, based on the current package source.\n\n\n\n\n\n\n\nFigure 4.4: devtools::load_all() vs. library().\n\n\n\n\nThe main benefits of load_all() include:\n\nYou can iterate quickly, which encourages exploration and incremental progress.\n\nThis iterative speedup is especially noticeable for packages with compiled code.\n\n\nYou get to develop interactively under a namespace regime that accurately mimics how things are when someone uses your installed package, with the following additional advantages:\n\nYou can call your own internal functions directly, without using ::: and without being tempted to temporarily define your functions in the global workspace.\nYou can also call functions from other packages that you’ve imported into your NAMESPACE, without being tempted to attach these dependencies via library().\n\n\n\nload_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management.\n\n4.4.2 调用 load_all() 的其它方法\nWhen working in a Project that is a package, RStudio offers several ways to call load_all():\n\nKeyboard shortcut: Cmd+Shift+L (macOS), Ctrl+Shift+L (Windows, Linux)\nBuild pane’s More … menu\nBuild &gt; Load All\n\ndevtools::load_all() is a thin wrapper around pkgload::load_all() that adds a bit of user-friendliness. It is unlikely you will use load_all() programmatically or inside another package, but if you do, you should probably use pkgload::load_all() directly.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-r-cmd-check",
    "href": "workflow101.html#sec-workflow101-r-cmd-check",
    "title": "4  基本开发工作流",
    "section": "\n4.5 check() 以及 R CMD check\n",
    "text": "4.5 check() 以及 R CMD check\n\nBase R provides various command line tools and R CMD check is the official method for checking that an R package is valid. It is essential to pass R CMD check if you plan to submit your package to CRAN, but we highly recommend holding yourself to this standard even if you don’t intend to release your package on CRAN. R CMD check detects many common problems that you’d otherwise discover the hard way.\nOur recommended way to run R CMD check is in the R console via devtools:\n\ndevtools::check()\n\nWe recommend this because it allows you to run R CMD check from within R, which dramatically reduces friction and increases the likelihood that you will check() early and often! This emphasis on fluidity and fast feedback is exactly the same motivation as given for load_all(). In the case of check(), it really is executing R CMD check for you. It’s not just a high fidelity simulation, which is the case for load_all().\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio exposes check() in the Build menu, in the Build pane via Check, and in keyboard shortcuts Ctrl + Shift + E (Windows & Linux) or Cmd + Shift + E (macOS).\n\n\nA rookie mistake that we see often in new package developers is to do too much work on their package before running R CMD check. Then, when they do finally run it, it’s typical to discover many problems, which can be very demoralizing. It’s counter-intuitive but the key to minimizing this pain is to run R CMD check more often: the sooner you find a problem, the easier it is to fix4. We model this behaviour very intentionally in Chapter 1.\nThe upper limit of this approach is to run R CMD check every time you make a change. We don’t run check() manually quite that often, but when we’re actively working on a package, it’s typical to check() multiple times per day. Don’t tinker with your package for days, weeks, or months, waiting for some special milestone to finally run R CMD check. If you use GitHub (?sec-sw-dev-practices-git-github), we’ll show you how to set things up so that R CMD check runs automatically every time you push (?sec-sw-dev-practices-gha).\n\n4.5.1 工作流\nHere’s what happens inside devtools::check():\n\nEnsures that the documentation is up-to-date by running devtools::document().\nBundles the package before checking it (Section 3.3). This is the best practice for checking packages because it makes sure the check starts with a clean slate: because a package bundle doesn’t contain any of the temporary files that can accumulate in your source package, e.g. artifacts like .so and .o files which accompany compiled code, you can avoid the spurious warnings such files will generate.\nSets the NOT_CRAN environment variable to \"true\". This allows you to selectively skip tests on CRAN. See ?testthat::skip_on_cran and ?sec-testing-advanced-skip-on-cran for details.\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check(), or press Ctrl/Cmd + Shift + E.\nFix the first problem.\nRepeat until there are no more problems.\n\nR CMD check returns three types of messages:\n\nERRORs: Severe problems that you should fix regardless of whether or not you’re submitting to CRAN.\nWARNINGs: Likely problems that you must fix if you’re planning to submit to CRAN (and a good idea to look into even if you’re not).\nNOTEs: Mild problems or, in a few cases, just an observation. If you are submitting to CRAN, you should strive to eliminate all NOTEs, even if they are false positives. If you have no NOTEs, human intervention is not required, and the package submission process will be easier. If it’s not possible to eliminate a NOTE, you’ll need describe why it’s OK in your submission comments, as described in ?sec-release-process. If you’re not submitting to CRAN, carefully read each NOTE. If it’s easy to eliminate the NOTEs, it’s worth it, so that you can continue to strive for a totally clean result. But if eliminating a NOTE will have a net negative impact on your package, it is reasonable to just tolerate it. Make sure that doesn’t lead to you ignoring other issues that really should be addressed.\n\nR CMD check consists of dozens of individual checks and it would be overwhelming to enumerate them here. See our online-only guide to R CMD check for details.\n\n4.5.2 R CMD check 的幕后工作\nAs you accumulate package development experience, you might want to access R CMD check directly at some point. Remember that R CMD check is something you must run in the terminal, not in the R console. You can see its documentation like so:\nR CMD check --help\nR CMD check can be run on a directory that holds an R package in source form (Section 3.2) or, preferably, on a package bundle (Section 3.3):\nR CMD build somepackage\nR CMD check somepackage_0.0.0.9000.tar.gz  \nTo learn more, see the Checking packages section of Writing R Extensions.\n\n\n\n\nSilge, Julia, John C. Nash, and Spencer Graves. 2018. “Navigating the R Package Universe.” The R Journal 10 (2): 558–63. https://doi.org/10.32614/RJ-2018-058.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "workflow101.html#footnotes",
    "href": "workflow101.html#footnotes",
    "title": "4  基本开发工作流",
    "section": "",
    "text": "Specifically, we configure Alfred to favor .Rproj files in its search results when proposing apps or files to open. To register the .Rproj file type with Alfred, go to Preferences &gt; Features &gt; Default Results &gt; Advanced. Drag any .Rproj file onto this space and then close.↩︎\nQuoting the usage philosophy favored by Emacs Speaks Statistics (ESS).↩︎\nThe command line approach is to quit R, go to the shell, do R CMD build foo in the package’s parent directory, then R CMD INSTALL foo_x.y.x.tar.gz, restart R, and call library(foo).↩︎\nA great blog post advocating for “if it hurts, do it more often” is FrequencyReducesDifficulty by Martin Fowler.↩︎",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  },
  {
    "objectID": "package-within.html",
    "href": "package-within.html",
    "title": "5  The package within",
    "section": "",
    "text": "5.1 Alfa: a script that works\nLet’s consider data-cleaning.R, a fictional data analysis script for a group that collects reports from people who went for a swim:\nTheir data usually comes as a CSV file, such as swim.csv:\nname,where,temp\nAdam,beach,95\nBess,coast,91\nCora,seashore,28\nDale,beach,85\nEvan,seaside,31\ndata-cleaning.R begins by reading swim.csv into a data frame:\ninfile &lt;- \"swim.csv\"\n(dat &lt;- read.csv(infile))\n#&gt;   name    where temp\n#&gt; 1 Adam    beach   95\n#&gt; 2 Bess    coast   91\n#&gt; 3 Cora seashore   28\n#&gt; 4 Dale    beach   85\n#&gt; 5 Evan  seaside   31\nThey then classify each observation as using American (“US”) or British (“UK”) English, based on the word chosen to describe the sandy place where the ocean and land meet. The where column is used to build the new english column.\ndat$english[dat$where == \"beach\"] &lt;- \"US\"\ndat$english[dat$where == \"coast\"] &lt;- \"US\"\ndat$english[dat$where == \"seashore\"] &lt;- \"UK\"\ndat$english[dat$where == \"seaside\"] &lt;- \"UK\"\nSadly, the temperatures are often reported in a mix of Fahrenheit and Celsius. In the absence of better information, they guess that Americans report temperatures in Fahrenheit and therefore those observations are converted to Celsius.\ndat$temp[dat$english == \"US\"] &lt;- (dat$temp[dat$english == \"US\"] - 32) * 5/9\ndat\n#&gt;   name    where temp english\n#&gt; 1 Adam    beach 35.0      US\n#&gt; 2 Bess    coast 32.8      US\n#&gt; 3 Cora seashore 28.0      UK\n#&gt; 4 Dale    beach 29.4      US\n#&gt; 5 Evan  seaside 31.0      UK\nFinally, this cleaned (cleaner?) data is written back out to a CSV file. They like to capture a timestamp in the filename when they do this1.\nnow &lt;- Sys.time()\ntimestamp &lt;- format(now, \"%Y-%B-%d_%H-%M-%S\")\n(outfile &lt;- paste0(timestamp, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile)))\n#&gt; [1] \"2024-二月-16_00-41-26_swim_clean.csv\"\nwrite.csv(dat, file = outfile, quote = FALSE, row.names = FALSE)\nHere is data-cleaning.R in its entirety:\ninfile &lt;- \"swim.csv\"\n(dat &lt;- read.csv(infile))\n\ndat$english[dat$where == \"beach\"] &lt;- \"US\"\ndat$english[dat$where == \"coast\"] &lt;- \"US\"\ndat$english[dat$where == \"seashore\"] &lt;- \"UK\"\ndat$english[dat$where == \"seaside\"] &lt;- \"UK\"\n\ndat$temp[dat$english == \"US\"] &lt;- (dat$temp[dat$english == \"US\"] - 32) * 5/9\ndat\n\nnow &lt;- Sys.time()\ntimestamp &lt;- format(now, \"%Y-%B-%d_%H-%M-%S\")\n(outfile &lt;- paste0(timestamp, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile)))\nwrite.csv(dat, file = outfile, quote = FALSE, row.names = FALSE)\nEven if your typical analytical tasks are quite different, hopefully you see a few familiar patterns here. It’s easy to imagine that this group does very similar pre-processing of many similar data files over time. Their analyses can be more efficient and consistent if they make these standard data maneuvers available to themselves as functions in a package, instead of inlining the same data and logic into dozens or hundreds of data ingest scripts.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#alfa-a-script-that-works",
    "href": "package-within.html#alfa-a-script-that-works",
    "title": "5  The package within",
    "section": "",
    "text": "Where did you swim and how hot was it outside?",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#bravo-a-better-script-that-works",
    "href": "package-within.html#bravo-a-better-script-that-works",
    "title": "5  The package within",
    "section": "\n5.2 Bravo: a better script that works",
    "text": "5.2 Bravo: a better script that works\nThe package that lurks within the original script is actually pretty hard to see! It’s obscured by a few suboptimal coding practices, such as the use of repetitive copy/paste-style code and the mixing of code and data. Therefore a good first step is to refactor this code, isolating as much data and logic as possible in proper objects and functions, respectively.\nThis is also a good time to introduce the use of some add-on packages, for several reasons. First, we would actually use the tidyverse for this sort of data wrangling. Second, many people use add-on packages in their scripts, so it is good to see how add-on packages are handled inside a package.\nHere’s the new and improved version of the script.\n\nlibrary(tidyverse)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\nlookup_table &lt;- tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\ndat &lt;- dat %&gt;% \n  left_join(lookup_table)\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\ndat &lt;- dat %&gt;% \n  mutate(temp = if_else(english == \"US\", f_to_c(temp), temp))\ndat\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\nwrite_csv(dat, outfile_path(infile))\n\nThe key changes to note are:\n\nWe are using functions from tidyverse packages (specifically from readr and dplyr) and we make them available with library(tidyverse).\nThe map between different “beach” words and whether they are considered to be US or UK English is now isolated in a lookup table, which lets us create the english column in one go with a left_join(). This lookup table makes the mapping easier to comprehend and would be much easier to extend in the future with new “beach” words.\n\nf_to_c(), timestamp(), and outfile_path() are new helper functions that hold the logic for converting temperatures and forming the timestamped output file name.\n\nIt’s getting easier to recognize the reusable bits of this script, i.e. the bits that have nothing to do with a specific input file, like swim.csv. This sort of refactoring often happens naturally on the way to creating your own package, but if it does not, it’s a good idea to do this intentionally.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#charlie-a-separate-file-for-helper-functions",
    "href": "package-within.html#charlie-a-separate-file-for-helper-functions",
    "title": "5  The package within",
    "section": "\n5.3 Charlie: a separate file for helper functions",
    "text": "5.3 Charlie: a separate file for helper functions\nA typical next step is to move reusable data and logic out of the analysis script and into one or more separate files. This is a conventional opening move, if you want to use these same helper files in multiple analyses.\nHere is the content of beach-lookup-table.csv:\n\nwhere,english\nbeach,US\ncoast,US\nseashore,UK\nseaside,UK\n\nHere is the content of cleaning-helpers.R:\n\nlibrary(tidyverse)\n\nlocalize_beach &lt;- function(dat) {\n  lookup_table &lt;- read_csv(\n    \"beach-lookup-table.csv\",\n    col_types = cols(where = \"c\", english = \"c\")\n  )\n  left_join(dat, lookup_table)\n}\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\ncelsify_temp &lt;- function(dat) {\n  mutate(dat, temp = if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nWe’ve added some high-level helper functions, localize_beach() and celsify_temp(), to the pre-existing helpers (f_to_c(), timestamp(), and outfile_path()).\nHere is the next version of the data cleaning script, now that we’ve pulled out the helper functions (and lookup table).\n\nlibrary(tidyverse)\nsource(\"cleaning-helpers.R\")\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\n(dat &lt;- dat %&gt;% \n    localize_beach() %&gt;% \n    celsify_temp())\n\nwrite_csv(dat, outfile_path(infile))\n\nNotice that the script is getting shorter and, hopefully, easier to read and modify, because repetitive and fussy clutter has been moved out of sight. Whether the code is actually easier to work with is subjective and depends on how natural the “interface” feels for the people who actually preprocess swimming data. These sorts of design decisions are the subject of a separate project: design.tidyverse.org.\nLet’s assume the group agrees that our design decisions are promising, i.e. we seem to be making things better, not worse. Sure, the existing code is not perfect, but this is a typical developmental stage when you’re trying to figure out what the helper functions should be and how they should work.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#delta-a-failed-attempt-at-making-a-package",
    "href": "package-within.html#delta-a-failed-attempt-at-making-a-package",
    "title": "5  The package within",
    "section": "\n5.4 Delta: a failed attempt at making a package",
    "text": "5.4 Delta: a failed attempt at making a package\nWhile this first attempt to create a package will end in failure, it’s still helpful to go through some common missteps, to illuminate what happens behind the scenes.\nHere are the simplest steps that you might take, in an attempt to convert cleaning-helpers.R into a proper package:\n\nUse usethis::create_package(\"path/to/delta\") to scaffold a new R package, with the name “delta”.\n\nThis is a good first step!\n\n\nCopy cleaning-helpers.R into the new package, specifically, to R/cleaning-helpers.R.\n\nThis is morally correct, but mechanically wrong in several ways, as we will soon see.\n\n\nCopy beach-lookup-table.csv into the new package. But where? Let’s try the top-level of the source package.\n\nThis is not going to end well. Shipping data files in a package is a special topic, which is covered in ?sec-data.\n\n\nInstall this package, perhaps using devtools::install() or via Ctrl + Shift + B (Windows & Linux) or Cmd + Shift + B in RStudio.\n\nDespite all of the problems identified above, this actually works! Which is interesting, because we can (try to) use it and see what happens.\n\n\n\nHere is the next version of the data cleaning script that you hope will run after successfully installing this package (which we’re calling “delta”).\n\nlibrary(tidyverse)\nlibrary(delta)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n\nwrite_csv(dat, outfile_path(infile))\n\nThe only change from our previous script is that\n\nsource(\"cleaning-helpers.R\")\n\nhas been replaced by\n\nlibrary(delta)\n\nHere’s what actually happens if you install the delta package and try to run the data cleaning script:\n\nlibrary(tidyverse)\nlibrary(delta)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n#&gt; Error in localize_beach(.) : could not find function \"localize_beach\"\n\nwrite_csv(dat, outfile_path(infile))\n#&gt; Error in outfile_path(infile) : could not find function \"outfile_path\"\n\nNone of the helper functions are actually available for use, even though you call library(delta)! In contrast to source()ing a file of helper functions, attaching a package does not dump its functions into the global workspace. By default, functions in a package are only for internal use. You need to export localize_beach(), celsify_temp(), and outfile_path() so your users can call them. In the devtools workflow, we achieve this by putting @export in the special roxygen comment above each function (namespace management is covered in ?sec-dependencies-NAMESPACE-workflow), like so:\n\n#' @export\ncelsify_temp &lt;- function(dat) {\n  mutate(dat, temp = if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nAfter you add the @export tag to localize_beach(), celsify_temp(), and outfile_path(), you run devtools::document() to (re)generate the NAMESPACE file, and re-install the delta package. Now when you re-execute the data cleaning script, it works!\nCorrection: it sort of works sometimes. Specifically, it works if and only if the working directory is set to the top-level of the source package. From any other working directory, you still get an error:\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n#&gt; Error: 'beach-lookup-table.csv' does not exist in current working directory ('/Users/jenny/tmp').\n\nThe lookup table consulted inside localize_beach() cannot be found. One does not simply dump CSV files into the source of an R package and expect things to “just work”. We will fix this in our next iteration of the package (?sec-data has full coverage of how to include data in a package).\nBefore we abandon this initial experiment, let’s also marvel at the fact that you were able to install, attach, and, to a certain extent, use a fundamentally broken package. devtools::load_all() works fine, too! This is a sobering reminder that you should be running R CMD check, probably via devtools::check(), very often during development. This will quickly alert you to many problems that simple installation and usage does not reveal.\nIndeed, check() fails for this package and you see this:\n * installing *source* package ‘delta’ ...\n ** using staged installation\n ** R\n ** byte-compile and prepare package for lazy loading\n Error in library(tidyverse) : there is no package called ‘tidyverse’\n Error: unable to load R code in package ‘delta’\n Execution halted\n ERROR: lazy loading failed for package ‘delta’\n * removing ‘/Users/jenny/rrr/delta.Rcheck/delta’\nWhat do you mean “there is no package called ‘tidyverse’”?!? We’re using it, with no problems, in our main script! Also, we’ve already installed and used this package, why can’t R CMD check find it?\nThis error is what happens when the strictness of R CMD check meets the very first line of R/cleaning-helpers.R:\n\nlibrary(tidyverse)\n\nThis is not how you declare that your package depends on another package (the tidyverse, in this case). This is also not how you make functions in another package available for use in yours. Dependencies must be declared in DESCRIPTION (and that’s not all). Since we declared no dependencies, R CMD check takes us at our word and tries to install our package with only the base packages available, which means this library(tidyverse) call fails. A “regular” installation succeeds, simply because the tidyverse is available in your regular library, which hides this particular mistake.\nTo review, copying cleaning-helpers.R to R/cleaning-helpers.R, without further modification, was problematic in (at least) the following ways:\n\nDoes not account for exported vs. non-exported functions.\nThe CSV file holding our lookup table cannot be found in the installed package.\nDoes not properly declare our dependency on other add-on packages.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#echo-a-working-package",
    "href": "package-within.html#echo-a-working-package",
    "title": "5  The package within",
    "section": "\n5.5 Echo: a working package",
    "text": "5.5 Echo: a working package\nWe’re ready to make the most minimal version of this package that actually works.\nHere is the new version of R/cleaning-helpers.R2:\n\nlookup_table &lt;- dplyr::tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\n#' @export\nlocalize_beach &lt;- function(dat) {\n  dplyr::left_join(dat, lookup_table)\n}\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\n#' @export\ncelsify_temp &lt;- function(dat) {\n  dplyr::mutate(dat, temp = dplyr::if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\n\n#' @export\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nWe’ve gone back to defining the lookup_table with R code, since the initial attempt to read it from CSV created some sort of filepath snafu. This is OK for small, internal, static data, but remember to see ?sec-data for more general techniques for storing data in a package.\nAll of the calls to tidyverse functions have now been qualified with the name of the specific package that actually provides the function, e.g. dplyr::mutate(). There are other ways to access functions in another package, explained in ?sec-dependencies-in-imports, but this is our recommended default. It is also our strong recommendation that no one depend on the tidyverse meta-package in a package3. Instead, it is better to identify the specific package(s) you actually use. In this case, the package only uses dplyr.\nThe library(tidyverse) call is gone and instead we declare the use of dplyr in the Imports field of DESCRIPTION:\nPackage: echo\n(... other lines omitted ...)\nImports: \n    dplyr\nThis, together with the use of namespace-qualified calls, like dplyr::left_join(), constitutes a valid way to use another package within yours. The metadata conveyed via DESCRIPTION is covered in ?sec-description.\nAll of the user-facing functions have an @export tag in their roxygen comment, which means that devtools::document() adds them correctly to the NAMESPACE file. Note that f_to_c() is currently only used internally, inside celsify_temp(), so it is not exported (likewise for timestamp()).\nThis version of the package can be installed, used, AND it technically passes R CMD check, though with 1 warning and 1 note.\n* checking for missing documentation entries ... WARNING\nUndocumented code objects:\n  ‘celsify_temp’ ‘localize_beach’ ‘outfile_path’\nAll user-level objects in a package should have documentation entries.\nSee chapter ‘Writing R documentation files’ in the ‘Writing R\nExtensions’ manual.\n\n* checking R code for possible problems ... NOTE\ncelsify_temp: no visible binding for global variable ‘english’\ncelsify_temp: no visible binding for global variable ‘temp’\nUndefined global functions or variables:\n  english temp\nThe “no visible binding” note is a peculiarity of using dplyr and unquoted variable names inside a package, where the use of bare variable names (english and temp) looks suspicious. You can add either of these lines to any file below R/ to eliminate this note (such as the package-level documentation file described in ?sec-man-package-doc):\n\n# option 1 (then you should also put utils in Imports)\nutils::globalVariables(c(\"english\", \"temp\"))\n\n# option 2\nenglish &lt;- temp &lt;- NULL\n\nWe’re seeing that it can be tricky to program around a package like dplyr, which makes heavy use of nonstandard evaluation. Behind the scenes, that is the technique that allows dplyr’s end users to use bare (not quoted) variable names. Packages like dplyr prioritize the experience of the typical end user, at the expense of making them trickier to depend on. The two options shown above for suppressing the “no visible binding” note, represent entry-level solutions. For a more sophisticated treatment of these issues, see vignette(\"in-packages\", package = \"dplyr\") and vignette(\"programming\", package = \"dplyr\").\nThe warning about missing documentation is because the exported functions have not been properly documented. This is a valid concern and something you should absolutely address in a real package. You’ve already seen how to create help files with roxygen comments in Section 1.12 and we cover this topic thoroughly in ?sec-man.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#sec-package-within-build-time-run-time",
    "href": "package-within.html#sec-package-within-build-time-run-time",
    "title": "5  The package within",
    "section": "\n5.6 Foxtrot: build time vs. run time",
    "text": "5.6 Foxtrot: build time vs. run time\nThe echo package works, which is great, but group members notice something odd about the timestamps:\n\nSys.time()\n#&gt; [1] \"2023-03-26 22:48:48 PDT\"\n\noutfile_path(\"INFILE.csv\")\n#&gt; [1] \"2020-September-03_11-06-33_INFILE_clean.csv\"\n\nThe datetime in the timestamped filename doesn’t reflect the time reported by the system. In fact, the users claim that the timestamp never seems to change at all! Why is this?\nRecall how we form the filepath for output files:\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nThe fact that we capture now &lt;- Sys.time() outside of the definition of outfile_path() has probably been vexing some readers for a while. now reflects the instant in time when we execute now &lt;- Sys.time(). In the initial approach, now was assigned when we source()d cleaning-helpers.R. That’s not ideal, but it was probably a pretty harmless mistake, because the helper file would be source()d shortly before we wrote the output file.\nBut this approach is quite devastating in the context of a package. now &lt;- Sys.time() is executed when the package is built4. And never again. It is very easy to assume your package code is re-evaluated when the package is attached or used. But it is not. Yes, the code inside your functions is absolutely run whenever they are called. But your functions – and any other objects created in top-level code below R/ – are defined exactly once, at build time.\nBy defining now with top-level code below R/, we’ve doomed our package to timestamp all of its output files with the same (wrong) time. The fix is to make sure the Sys.time() call happens at run time.\nLet’s look again at parts of R/cleaning-helpers.R:\n\nlookup_table &lt;- dplyr::tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nThere are four top-level &lt;- assignments in this excerpt. The top-level definitions of the data frame lookup_table and the functions timestamp() and outfile_path() are correct. It is appropriate that these be defined exactly once, at build time. The top-level definition of now, which is then used inside outfile_path(), is regrettable.\nHere are better versions of outfile_path():\n\n# always timestamp as \"now\"\noutfile_path &lt;- function(infile) {\n  ts &lt;- timestamp(Sys.time())\n  paste0(ts, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\n# allow user to provide a time, but default to \"now\"\noutfile_path &lt;- function(infile, time = Sys.time()) {\n  ts &lt;- timestamp(time)\n  paste0(ts, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nThis illustrates that you need to have a different mindset when defining objects inside a package. The vast majority of those objects should be functions and these functions should generally only use data they create or that is passed via an argument. There are some types of sloppiness that are fairly harmless when a function is defined immediately before its use, but that can be more costly for functions distributed as a package.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#sec-package-within-side-effects",
    "href": "package-within.html#sec-package-within-side-effects",
    "title": "5  The package within",
    "section": "\n5.7 Golf: side effects",
    "text": "5.7 Golf: side effects\nThe timestamps now reflect the current time, but the group raises a new concern. As it stands, the timestamps reflect who has done the data cleaning and which part of the world they’re in. The heart of the timestamp strategy is this format string5:\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n#&gt; [1] \"2024-二月-16_00-41-27\"\n\nThis formats Sys.time() in such a way that it includes the month name (not number) and the local time6.\nTable 5.1 shows what happens when such a timestamp is produced by several hypothetical colleagues cleaning some data at exactly the same instant in time.\n\n\n\nTable 5.1: Timestamp varies by locale and timezone.\n\n\n\n\n\n\n\n\n\n\nlocation\ntimestamp\nLC_TIME\ntz\n\n\n\nRome, Italy\n2020-settembre-05_00-30-00\nit_IT.UTF-8\nEurope/Rome\n\n\nWarsaw, Poland\n2020-wrzesień-05_00-30-00\npl_PL.UTF-8\nEurope/Warsaw\n\n\nSao Paulo, Brazil\n2020-setembro-04_19-30-00\npt_BR.UTF-8\nAmerica/Sao_Paulo\n\n\nGreenwich, England\n2020-September-04_23-30-00\nen_GB.UTF-8\nEurope/London\n\n\n“Computer World!”\n2020-September-04_22-30-00\nC\nUTC\n\n\n\n\n\n\n\n\nNote that the month names vary, as does the time, and even the date! The safest choice is to form timestamps with respect to a fixed locale and time zone (presumably the non-geographic choices represented by “Computer World!” above).\nYou do some research and learn that you can force a certain locale via Sys.setlocale() and force a certain time zone by setting the TZ environment variable. Specifically, we set the LC_TIME component of the locale to “C” and the time zone to “UTC” (Coordinated Universal Time). Here’s your first attempt to improve timestamp():\n\ntimestamp &lt;- function(time = Sys.time()) {\n  Sys.setlocale(\"LC_TIME\", \"C\")\n  Sys.setenv(TZ = \"UTC\")\n  format(time, \"%Y-%B-%d_%H-%M-%S\")\n}\n\nBut your Brazilian colleague notices that datetimes print differently, before and after she uses outfile_path() from your package:\nBefore:\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n\n\n#&gt; [1] \"2024-fevereiro-15_13-41-27\"\n\nAfter:\n\noutfile_path(\"INFILE.csv\")\n#&gt; [1] \"2024-February-15_16-41-27_INFILE_clean.csv\"\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n#&gt; [1] \"2024-February-15_16-41-28\"\n\nNotice that her month name switched from Portuguese to English and the time is clearly being reported in a different time zone. The calls to Sys.setlocale() and Sys.setenv() inside timestamp() have made persistent (and very surprising) changes to her R session. This sort of side effect is very undesirable and is extremely difficult to track down and debug, especially in more complicated settings.\nHere are better versions of timestamp():\n\n# use withr::local_*() functions to keep the changes local to timestamp()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::local_locale(c(\"LC_TIME\" = \"C\"))\n  withr::local_timezone(\"UTC\")\n  format(time, \"%Y-%B-%d_%H-%M-%S\")\n}\n\n# use the tz argument to format.POSIXct()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::local_locale(c(\"LC_TIME\" = \"C\"))\n  format(time, \"%Y-%B-%d_%H-%M-%S\", tz = \"UTC\")\n}\n\n# put the format() call inside withr::with_*()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::with_locale(\n    c(\"LC_TIME\" = \"C\"),\n    format(time, \"%Y-%B-%d_%H-%M-%S\", tz = \"UTC\")\n  )\n}\n\nThese show various methods to limit the scope of our changes to LC_TIME and the timezone. A good rule of thumb is to make the scope of such changes as narrow as possible and practical. The tz argument of format() is the most surgical way to deal with the timezone, but nothing similar exists for LC_TIME. We make the temporary locale modification using the withr package, which provides a very flexible toolkit for temporary state changes. This (and base::on.exit()) are discussed further in ?sec-code-r-landscape. Note that if you use withr as we do above, you would need to list it in DESCRIPTION in Imports (?sec-dependencies-in-practice, ?sec-dependencies-tidyverse).\nThis underscores a point from the previous section: you need to adopt a different mindset when defining functions inside a package. Try to avoid making any changes to the user’s overall state. If such changes are unavoidable, make sure to reverse them (if possible) or to document them explicitly (if related to the function’s primary purpose).",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#concluding-thoughts",
    "href": "package-within.html#concluding-thoughts",
    "title": "5  The package within",
    "section": "\n5.8 Concluding thoughts",
    "text": "5.8 Concluding thoughts\nFinally, after several iterations, we have successfully extracted the repetitive data cleaning code for the swimming survey into an R package. This example concludes the first part of the book and marks the transition into more detailed reference material on specific package components. Before we move on, let’s review the lessons learned in this chapter.\n\n5.8.1 Script vs. package\nWhen you first hear that expert R users often put their code into packages, you might wonder exactly what that means. Specifically, what happens to your existing R scripts, R Markdown reports, and Shiny apps? Does all of that code somehow get put into a package? The answer is “no”, in most contexts.\nTypically, you identify certain recurring operations that occur across multiple projects and this is what you extract into an R package. You will still have R scripts, R Markdown reports, and Shiny apps, but by moving specific pieces of code into a formal package, your data products tend to become more concise and easier to maintain.\n\n5.8.2 Finding the package within\nAlthough the example in this chapter is rather simple, it still captures the typical process of developing an R package for personal or organizational use. You typically start with a collection of idiosyncratic and related R scripts, scattered across different projects. Over time, you begin to notice that certain needs come up over and over again.\nEach time you revisit a similar analysis, you might try to elevate your game a bit, compared to the previous iteration. You refactor copy/paste-style code using more robust patterns and start to encapsulate key “moves” in helper functions, which might eventually migrate into their own file. Once you reach this stage, you’re in a great position to take the next step and create a package.\n\n5.8.3 Package code is different\nWriting package code is a bit different from writing R scripts and it’s natural to feel some discomfort when making this adjustment. Here are the most common gotchas that trip many of us up at first:\n\nPackage code requires new ways of working with functions in other packages. The DESCRIPTION file is the principal way to declare dependencies; we don’t do this via library(somepackage).\nIf you want data or files to be persistently available, there are package-specific methods of storage and retrieval. You can’t just put files in the package and hope for the best.\nIt’s necessary to be explicit about which functions are user-facing and which are internal helpers. By default, functions are not exported for use by others.\nA new level of discipline is required to ensure that code runs at the intended time (build time vs. run time) and that there are no unintended side effects.",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "package-within.html#footnotes",
    "href": "package-within.html#footnotes",
    "title": "5  The package within",
    "section": "",
    "text": "Sys.time() returns an object of class POSIXct, therefore when we call format() on it, we are actually using format.POSIXct(). Read the help for ?format.POSIXct if you’re not familiar with such format strings.↩︎\nPutting everything in one file, with this name, is not ideal, but it is technically allowed. We discuss organising and naming the files below R/ in ?sec-code-organising.↩︎\nThe blog post The tidyverse is for EDA, not packages elaborates on this.↩︎\nHere we’re referring to when the package code is compiled, which could be either when the binary is made (for macOS or Windows; Section 3.4) or when the package is installed from source (Section 3.5).↩︎\nSys.time() returns an object of class POSIXct, therefore when we call format() on it, we are actually using format.POSIXct(). Read the help for ?format.POSIXct if you’re not familiar with such format strings.↩︎\nIt would clearly be better to format according to ISO 8601, which encodes the month by number, but please humor me for the sake of making this example more obvious.↩︎",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The package within</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "6  References",
    "section": "",
    "text": "Marwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a.\n“Packaging Data Analytical Work Reproducibly Using r (and\nFriends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r\n(and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive\nPretty Printing of R Code. http://styler.r-lib.org.\n\n\nSilge, Julia, John C. Nash, and Spencer Graves. 2018. “Navigating the R Package Universe.”\nThe R Journal 10 (2): 558–63. https://doi.org/10.32614/RJ-2018-058.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>References</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html",
    "href": "R-CMD-check.html",
    "title": "Appendix A — R CMD check",
    "section": "",
    "text": "A.1 Check metadata\nR CMD check always starts by describing your current environment.\nNext the DESCRIPTION file is parsed and the package version and encoding is printed.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#check-metadata",
    "href": "R-CMD-check.html#check-metadata",
    "title": "Appendix A — R CMD check",
    "section": "",
    "text": "Using log directory ‘/some/tmp/path/googledrive.Rcheck’\n\nUsing R version 4.2.2 (2022-10-31)\n\nUsing platform: x86_64-apple-darwin17.0 (64-bit)\n\nUsing session charset: UTF-8\n\n\n\n\n\nChecking for file ‘googledrive/DESCRIPTION’\n\nThis is package ‘googledrive’ version ‘2.1.0.9000’\n\nPackage encoding: UTF-8",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#package-structure",
    "href": "R-CMD-check.html#package-structure",
    "title": "Appendix A — R CMD check",
    "section": "\nA.2 Package structure",
    "text": "A.2 Package structure\n\n\n\nChecking package directory. The directory you’re checking must exist - devtools::check() protects you against this problem.\n\n\n\nChecking if this is a source package. You must check a source package, not a binary or installed package. This should never fail if you use devtools::check().\n\n\n\nChecking for executable files. You must not have executable files in your package: they’re not portable, they’re not open source, and they are a security risk. Delete any executable files from your package. (If you’re not submitting to CRAN, you can silence this warning by listing each executable file in the BinaryFiles field in your DESCRIPTION.)\n\n\n\nChecking for hidden files and directories. On Linux and macOS, files with a name starting with . are hidden by default, and you’ve probably included them in your package by mistake. Either delete them, or if they are important, use .Rbuildignore to remove them from the package bundle. R automatically removes some common directories like .git and .svn.\n\n\n\nChecking for portable file names. R packages must work on Windows, Linux and macOS, so you can only use file names that work on all platforms. The easiest way to do this is to stick to letters, numbers, underscores and dashes. Avoid non-English letters and spaces. Fix this check by renaming the listed files.\n\n\n\nChecking for sufficient/correct file permissions. If you can’t read a file, you can’t check it. This check detects the unlikely occurrence that you have files in the package that you don’t have permission to read. Fix this problem by fixing the file permissions.\n\n\n\nChecking whether package ‘XYZ’ can be installed. R CMD check runs R CMD INSTALL to make sure that it’s possible to install your package. If this fails, you should run devtools::install() or the equivalent from RStudio’s menus and debug any problems before continuing.\n\n\n\nChecking installed package size. It’s easy to accidentally include large files that blow up the size of your package. This check ensures that the whole package is less than 5 MB and each subdirectory is less than 1 MB. If you see this message, check that you haven’t accidentally included a large file.\nIf submitting to CRAN, you’ll need to justify the size of your package. First, make sure the package is as small as it possibly can be: try recompressing the data, ?sec-data-data-raw; and minimising vignettes, ?sec-vignettes. If it’s still too large, consider moving data into its own package.\n\n\n\n\nChecking top-level files. Only specified files and directories are allowed at the top level of the package (e.g. DESCRIPTION, R/, src/). To include other files, you have two choices:\n\nIf they don’t need to be installed (i.e. they’re only used for development tasks), add them to .Rbuildignore with usethis::use_build_ignore().\nIf they need to be installed: move them into inst/. They’ll be moved back to the top-level package directory when installed. Learn more in ?sec-misc-inst.\n\n\n\n\n\nChecking package subdirectories.\n\nDon’t include any empty directories. These are usually removed automatically by R CMD build so you shouldn’t see this error. If you do, just delete the empty directory.\nThe case of files and directories is important. All sub-directories should be lower-case, except for R/. A citation file, if present, should be in inst/CITATION. Rename as needed.\nThe contents of inst/ shouldn’t clash with top-level contents of the package, such as data/ or R/. If they do, rename your files/directories. Learn more in ?sec-misc-inst.\n\n\n\n\n\nChecking for left-over files. Remove any files listed here. They’ve been included in your package by accident.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#description",
    "href": "R-CMD-check.html#description",
    "title": "Appendix A — R CMD check",
    "section": "\nA.3 DESCRIPTION\n",
    "text": "A.3 DESCRIPTION\n\n\n\n\nChecking DESCRIPTION meta-information.\n\nThe DESCRIPTION must be valid. You are unlikely to see this error, because devtools::load_all() runs the same check each time you re-load the package.\nIf you use any non-ASCII characters in the DESCRIPTION, you must also specify an encoding. There are only three encodings that work on all platforms: latin1, latin2 and UTF-8. We strongly recommend UTF-8: Encoding: UTF-8. Learn more in ?sec-data-non-ascii.\nThe License must refer to either a known license (a complete list can be found at https://svn.r-project.org/R/trunk/share/licenses/license.db), or it must use file LICENSE and that file must exist. Errors here are most likely to be typos. Learn more in ?sec-license.\nYou should either provide Authors@R or Authors and Maintainer. You’ll get an error if you’ve specified both, which you can fix by removing the one you didn’t want. Learn more in ?sec-description-authors-at-r.\n\n\n\n\n\nChecking package dependencies.\n\nAll packages listed in Depends, Imports and LinkingTo must be installed, and their version requirements must be met, otherwise your package can’t be checked.\nPackages listed in Suggests must be installed, unless you’ve set the environment variable _R_CHECK_FORCE_SUGGESTS_ to a false value (e.g. with check(force_suggests = FALSE)). This is useful if some of the suggested packages are not available on all platforms.\nAn easy way to install any missing or outdated dependencies is to run devtools::install_deps(dependencies = TRUE). See also pak::local_install_deps() and pak::local_install_dev_deps().\nR packages can not have a cycle of dependencies: i.e. if package A requires B, then B can not require A (otherwise which one would you load first?). If you see this error, you’ll need to rethink the design of your package. One easy fix is to move the conflicting package from Imports or Depends to Suggests.\nAny packages used in the NAMESPACE must be listed in one of Imports (most commonly) or Depends (only in special cases).\nEvery package listed in Depends must also be imported in the NAMESPACE or accessed with pkg::foo(). If you don’t do this, your package will work when attached to the search path (with library(mypackage)) but will not work when only loaded (e.g. mypackage::foo())\n\n\n\n\n\nChecking CRAN incoming feasibility. These checks only apply if you’re submitting to CRAN.\n\nIf you’re submitting a new package, you can’t use the same name as an existing package. You’ll need to come up with a new name.\nIf you’re submitting an update, the version number must be higher than the current CRAN version. Update the Version field in DESCRIPTION.\nIf the maintainer of the package has changed (even if it’s just a change in email address), the new maintainer should submit to CRAN, and the old maintainer will receive an email prompting them to confirm the change.\nYou must use a standard open source license, as listed in https://svn.r-project.org/R/trunk/share/licenses/license.db. You can not use a custom license as CRAN does not have the legal resources to review custom agreements.\nThe Title and Description must be free from spelling mistakes. The title of the package must be in title case. Neither title nor description should include either the name of your package or the word “package”. Reword your title and description as needed.\nIf you’re submitting a new package, you’ll always get a NOTE. This reminds the CRAN maintainers to do some extra manual checks.\nAvoid submitting multiple versions of the same package in a short period of time. CRAN prefers at most one submission per month. If you need to fix a major bug, be apologetic.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#namespace",
    "href": "R-CMD-check.html#namespace",
    "title": "Appendix A — R CMD check",
    "section": "\nA.4 Namespace",
    "text": "A.4 Namespace\n\n\n\nChecking if there is a namespace. You must have a NAMESPACE file. This is handled for your automatically by the devtools workflow.\n\n\n\nChecking package namespace information. The NAMESPACE should be parseable by parseNamespaceFile() and valid. If this check fails, it’s a bug in roxygen2.\n\n\n\nChecking whether the package can be loaded with stated dependencies. Runs library(pkg) with R_DEFAULT_PACKAGES=NULL, so the search path is empty (i.e. stats, graphics, grDevices, utils, datasets and methods are not attached like usual). Failure here typically indicates that you’re missing a dependency on one of those packages.\n\n\n\nChecking whether the namespace can be loaded with stated dependencies. Runs loadNamespace(pkg) with R_DEFAULT_PACKAGES=NULL. Failure usually indicates a problem with the namespace.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#r-code",
    "href": "R-CMD-check.html#r-code",
    "title": "Appendix A — R CMD check",
    "section": "\nA.5 R code",
    "text": "A.5 R code\n\n\n\nChecking R files for non-ASCII characters. For maximum portability (i.e. so people can use your package on Windows) you should avoid using non-ASCII characters in R files. It’s ok to use them in comments, but object names shouldn’t use them, and in strings you should use unicode escapes. See the CRAN-specific notes in ?sec-r for more details.\n\n\n\nChecking R files for syntax errors. Obviously your R code must be valid. You’re unlikely to see this error if you’ve been regularly using devtools::load_all().\n\n\n\nChecking dependencies in R code. Errors here often indicate that you’ve forgotten to declare a needed package in the DESCRIPTION. Remember that you should never use require() or library() inside a package - see ?sec-description-imports-suggests, ?sec-dependencies-mindset-background, and ?sec-dependencies-in-practice for more details on best practices.\nAlternatively, you may have accidentally used ::: to access an exported function from a package. Switch to :: instead.\n\n\n\n\nChecking S3 generic/method consistency. S3 methods must have a compatible function signature with their generic. This means that the method must have the same arguments as its generic, with one exception: if the generic includes ... the method can have additional arguments.\nA common cause of this error is defining print methods, because the print() generic contains...:\n\n# BAD\nprint.my_class &lt;- function(x) cat(\"Hi\")\n\n# GOOD\nprint.my_class &lt;- function(x, ...) cat(\"Hi\")\n\n# Also ok\nprint.my_class &lt;- function(x, ..., my_arg = TRUE) cat(\"Hi\")\n\n\n\n\n\nChecking replacement functions. Replacement functions (e.g. functions that are called like foo(x) &lt;- y), must have value as the last argument.\n\n\n\nChecking R code for possible problems. This is a compound check for a wide range of problems:\n\nCalls to library.dynam() (and library.dynam.unload()) should look like library.dynam(\"name\"), not library.dynam(\"name.dll\"). Remove the extension to fix this error.\nPut library.dynam() in .onLoad(), not .onAttach(); put packageStartupMessage() in .onAttach(), not .onLoad(). Put library.dynam.unload() in .onUnload(). If you use any of these functions, make sure they’re in the right place.\nDon’t use unlockBinding() or assignInNamespace() to modify objects that don’t belong to you.\ncodetools::checkUsagePackage() is called to check that your functions don’t use variables that don’t exist. This sometimes raises false positives with functions that use non-standard evaluation (NSE), like subset() or with(). Generally, we think you should avoid NSE in package functions, and hence avoid this NOTE, but if you can not, see ?globalVariables for how to suppress this NOTE.\nYou are not allowed to use .Internal() in a package. Either call the R wrapper function, or write your own C function. (If you copy and paste the C function from base R, make sure to maintain the copyright notice, use a GPL-2 compatible license, and list R-core in the Authors@R field.)\nSimilarly you are not allowed to use ::: to access non-exported functions from other packages. Either ask the package maintainer to export the function you need, or write your own version of it using exported functions. Alternatively, if the licenses are compatible you can copy and paste the exported function into your own package. If you do this, remember to update Authors@R.\nDon’t use assign() to modify objects in the global environment. If you need to maintain state across function calls, create your own environment, as described in ?sec-data-state.\nDon’t use attach() in your code. Instead refer to variables explicitly.\nDon’t use data() without specifying the envir argument. Otherwise the data will be loaded in the global environment.\nDon’t use deprecated or defunct functions. Update your code to use the latest versions.\nYou must use TRUE and FALSE in your code (and examples), not T and F.\n\n\n\n\n\nChecking whether the package can be loaded. R loads your package with library(). Failure here typically indicates a problem with .onLoad() or .onAttach().\n\n\n\nChecking whether the package can be unloaded cleanly. Loads with library() and then detach()es. If this fails, check .onUnload() and .onDetach().\n\n\n\nChecking whether the namespace can be unloaded cleanly. Runs loadNamespace(\"pkg\"); unloadNamespace(\"pkg\"). Check .onUnload() for problems.\n\n\n\nChecking loading without being on the library search path. Calls library(x, lib.loc = ...). Failure here indicates that you are making a false assumption in .onLoad() or .onAttach().",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#data",
    "href": "R-CMD-check.html#data",
    "title": "Appendix A — R CMD check",
    "section": "\nA.6 Data",
    "text": "A.6 Data\n\n\n\nChecking contents of ‘data’ directory.\n\nThe data directory can only contain file types described in ?sec-data-data.\nData files can contain non-ASCII characters only if the encoding is correctly set. This usually shouldn’t be a problem if you’re saving .Rdata files. If you do see this error, look at the Encoding() of each column in the data frame, and ensure none are “unknown”. (You’ll typically need to fix this somewhere in the import process). Learn more in ?sec-data-non-ascii.\nIf you’ve compressed a data file with bzip2 or xz you need to declare at least Depends: R (&gt;= 2.10) in your DESCRIPTION.\nIf you’ve used a sub-optimal compression algorithm for your data, re-compress with the suggested algorithm.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#documentation",
    "href": "R-CMD-check.html#documentation",
    "title": "Appendix A — R CMD check",
    "section": "\nA.7 Documentation",
    "text": "A.7 Documentation\nIf you’re grappling with documentation problems specifically, you may be able to iterate more quickly by using devtools::check_man(), which attempts to run only the relevant subset of checks. It also automatically calls devtools::document() for you.\n\n\n\nChecking Rd files. This checks that all man/*.Rd files use the correct Rd syntax. If this fails, it indicates a bug in roxygen2.\n\n\n\nChecking Rd metadata. Names and aliases must be unique across all documentation files in a package. If you encounter this problem you’ve accidentally used the same @name or @aliases in multiple places; make sure they’re unique.\n\n\n\nChecking Rd line widths. Lines in Rd files must be less than 90 characters wide. This is unlikely to occur if you wrap your R code, and hence roxygen comments, to 80 characters. For very long URLs, use a link-shortening service like bit.ly.\n\n\n\nChecking Rd cross-references. Errors here usually represent typos.\n\n\n\nChecking for missing documentation entries. All exported objects must be documented. See ?tools::undoc for more details.\n\n\n\nChecking for code/documentation mismatches. This check ensures that the documentation matches the code. This should never fail because you’re using roxygen2 which automatically keeps them in sync and check() should usually re-document() your package. In any case, the solution is often to re-run devtools::document().\n\n\n\nChecking Rd \\usage sections. All arguments must be documented, and all @params must document an existing argument. You may have forgotten to document an argument, forgotten to remove the documentation for an argument that you’ve removed, or misspelled an argument name.\nS3 and S4 methods need to use special \\S3method{} and \\S4method{} markup in the Rd file. Roxygen2 will generate this for you automatically.\n\n\n\n\nChecking Rd contents. This checks for auto-generated content made by package.skeleton(). Since you’re not using package.skeleton() you should never have a problem here.\n\n\n\nChecking for unstated dependencies in examples. If you use a package only for an example, make sure it’s listed in the Suggests field. Learn more about how to use different types of dependencies in your examples in ?sec-dependencies-in-practice.\n\n\n\nChecking examples. Every documentation example must run without errors, and must not take too long. See ?sec-man-examples for details.\n\n\n\nChecking PDF version of manual. Occasionally you’ll get an error when building the PDF manual. This is usually because the pdf is built by latex and you’ve forgotten to escape something. Debugging this is painful - your best bet is to look up the latex logs and combined tex file and work back from there to .Rd files then back to a roxygen comment. Any such failure is potentially a bug in roxygen2, so open an issue.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#demos",
    "href": "R-CMD-check.html#demos",
    "title": "Appendix A — R CMD check",
    "section": "\nA.8 Demos",
    "text": "A.8 Demos\n\n\n\nChecking index information. If you’ve written demos, each demo must be listed in demo/00Index. The file should look like:\ndemo-name-without-extension  Demo description\nanother-demo-name            Another description",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#compiled-code",
    "href": "R-CMD-check.html#compiled-code",
    "title": "Appendix A — R CMD check",
    "section": "\nA.9 Compiled code",
    "text": "A.9 Compiled code\n\n\n\nChecking foreign function calls. .Call(), .C(), .Fortran(), .External() must always be called either with a NativeSymbolInfo object (as created with @useDynLib) or use the .package argument. See ?tools::checkFF for more details.\n\n\n\nChecking line endings in C/C++/Fortran sources/headers. Always use LF as a line ending.\n\n\n\nChecking line endings in Makefiles. As above.\n\n\n\nChecking for portable use of $(BLAS_LIBS) and $(LAPACK_LIBS). Errors here indicate an issue with your use of BLAS and LAPACK.\n\n\n\nChecking compiled code. Checks that you’re not using any C functions that you shouldn’t.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#tests",
    "href": "R-CMD-check.html#tests",
    "title": "Appendix A — R CMD check",
    "section": "\nA.10 Tests",
    "text": "A.10 Tests\n\n\n\nChecking for unstated dependencies in tests. Every package used by tests must be included in the dependencies.\n\n\n\nChecking tests. Each file in tests/ is run. If you’ve followed the instructions in ?sec-testing-basics you’ll have at least one file: testthat.R. The output from R CMD check is not usually that helpful, so you may need to look at the log file package.Rcheck/tests/testthat.Rout. Fix any failing tests by iterating with devtools::test().\nOccasionally you may have a problem where the tests pass when run interactively with devtools::test(), but fail when in R CMD check. This usually indicates that you’ve made a faulty assumption about the testing environment, and it’s often hard to figure it out.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#vignettes",
    "href": "R-CMD-check.html#vignettes",
    "title": "Appendix A — R CMD check",
    "section": "\nA.11 Vignettes",
    "text": "A.11 Vignettes\nThis is a tricky enough topic that it also receives substantial coverage in the main body of the book; see ?sec-vignettes-how-built-checked.\n\n\n\nChecking ‘build’ directory. build/ is used to track vignette builds. It’s hard to imagine how this check could fail unless you’ve accidentally .Rbuildignored the build/ directory.\n\n\n\nChecking installed files from ‘inst/doc’. Don’t put files in inst/doc - keep your vignettes and the files they need in vignettes/.\n\n\n\nChecking files in ‘vignettes’. Problems here are usually straightforward - you’ve included files that are already included in R (like jss.cls, jss.bst, or Sweave.sty), or you have leftover latex compilation files. Delete these files.\n\n\n\nChecking for sizes of PDF files under ‘inst/doc’. If you’re making PDF vignettes, you can make them as small as possible by running tools::compactPDF().\n\n\n\nChecking for unstated dependencies in vignettes. As with tests, every package that you use in a vignette must be listed in the DESCRIPTION. If a package is used only for a vignette, and not elsewhere, make sure it’s listed in Suggests. If you really want to use a package and you don’t want to list it in DESCRIPTION, write an article instead of a vignette.\n\n\n\nChecking package vignettes in ‘inst/doc’. This checks that every source vignette (i.e. .Rmd) has a built equivalent (i.e. .html) in inst/doc. This shouldn’t fail if you’ve used the standard process outlined in ?sec-vignettes. If there is a problem, start by checking your .Rbuildignore.\n\n\n\nChecking running R code from vignettes. The R code from each vignette is run. If you want to deliberately execute errors (to show the user what failure looks like), make sure the chunk has error = TRUE, purl = FALSE.\n\n\n\nChecking re-building of vignette outputs. Each vignette is re-knit to make sure that the output corresponds to the input. Again, this shouldn’t fail in normal circumstances.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "href": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "title": "Appendix A — R CMD check",
    "section": "\nA.12 NOTEs that are informational",
    "text": "A.12 NOTEs that are informational\nOur blanket advice is to eliminate all ERRORs, WARNINGs, and even NOTEs that you see in R CMD check. But there are a few exceptions, i.e. there are a couple of NOTEs that do you not need to fix (and, indeed, probably can not fix).\n\nA.12.1 Initial CRAN submission\nWhen a package first goes to CRAN, there will always be one NOTE that alerts the CRAN maintainers that this is a new submission and that they’ll need to do some extra checks. You can’t eliminate this NOTE.\n* checking CRAN incoming feasibility ... NOTE\nMaintainer: 'Jane Doe &lt;jane@example.com&gt;'\n\nNew submission\n\nA.12.2 Non-ASCII characters in data\nIf your package’s data contains non-ASCII characters, you will get a NOTE like this, but it does not necessarily mean you need to do anything about it.\nCheck: data for non-ASCII characters\nResult: NOTE\n     Note: found 25 marked UTF-8 strings\nAs long as you are aware of the non-ASCII characters and the NOTE mentions your intended and declared encoding (preferably UTF-8), all is well.\n\nA.12.3 Rd cross-references\nIf your roxygen comments contain a cross-reference to a package that is not a formal, direct dependency, you might see a NOTE like this:\nCheck: Rd cross-references\nResult: NOTE\n    Undeclared package ‘jsonlite’ in Rd xrefs\nThis could happen if you want to document something related to a hard indirect dependency: There’s a legitimate reason to link to a topic in the other package and it is basically guaranteed to be installed. Therefore, in practice, often more good than harm comes from the cross-reference.\nIn our experience, this NOTE is only seen on certain CRAN check flavors and not others. Thus far, we have never been directed to address this NOTE by CRAN maintainers.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "workflow101.html#工作目录和文件路径规范",
    "href": "workflow101.html#工作目录和文件路径规范",
    "title": "4  基本开发工作流",
    "section": "\n4.3 工作目录和文件路径规范",
    "text": "4.3 工作目录和文件路径规范\nAs you develop your package, you will be executing R code. This will be a mix of workflow calls (e.g., document() or test()) and ad hoc calls that help you write your functions, examples, and tests. We strongly recommend that you keep the top-level of your source package as the working directory of your R process. This will generally happen by default, so this is really a recommendation to avoid development workflows that require you to fiddle with working directory.\nIf you’re totally new to package development, you don’t have much basis for supporting or resisting this proposal. But those with some experience may find this recommendation somewhat upsetting. You may be wondering how you are supposed to express paths when working in subdirectories, such as tests/. As it becomes relevant, we’ll show you how to exploit path-building helpers, such as testthat::test_path(), that determine paths at execution time.\nThe basic idea is that by leaving working directory alone, you are encouraged to write paths that convey intent explicitly (“read foo.csv from the test directory”) instead of implicitly (“read foo.csv from current working directory, which I think is going to be the test directory”). A sure sign of reliance on implicit paths is incessant fiddling with your working directory, because you’re using setwd() to manually fulfill the assumptions that are implicit in your paths.\nUsing explicit paths can design away a whole class of path headaches and makes day-to-day development more pleasant as well. There are two reasons why implicit paths are hard to get right:\n\nRecall the different forms that a package can take during the development cycle (Chapter 3). These states differ from each other in terms of which files and folders exist and their relative positions within the hierarchy. It’s tricky to write relative paths that work across all package states.\nEventually, your package will be processed with built-in tools like R CMD build, R CMD check, and R CMD INSTALL, by you and potentially CRAN. It’s hard to keep track of what the working directory will be at every stage of these processes.\n\nPath helpers like testthat::test_path(), fs::path_package(), and the rprojroot package are extremely useful for building resilient paths that hold up across the whole range of situations that come up during development and usage. Another way to eliminate brittle paths is to be rigorous in your use of proper methods for storing data inside your package (?sec-data) and to target the session temp directory when appropriate, such as for ephemeral testing artefacts (?sec-testing-basics).",
    "crumbs": [
      "入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>基本开发工作流</span>"
    ]
  }
]