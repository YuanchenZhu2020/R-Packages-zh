第二章 整个流程
================

\ *剧透警告！*\ 

本章介绍了一个小型玩具程序包\ :sub:`存疑`\ 的开发。这是为了在我们深入研究 R 包的关键组件之前，\
描绘开发的大图景并提出对一个工作流程的建议。

为了保持快节奏，我们利用了 devtools 程序包和 RStudio IDE 中的现代化的便利功能在之后的章节中，\
我们将更详细地介绍它们能帮助我们做些什么。


2.1 加载 devtools 和 friends
----------------------------

加载 devtools 程序包，在支持程序包开发的各个方面的程序包中，它是个中翘楚。

.. code-block:: R

    library(devtools)
    #> Loading required package: usethis

仅仅出于演示目的，我们使用 \ `fs <https://fs.r-lib.org/>`__\  帮助我们在文件系统上工作，\
使用 \ `tidyverse <https://tidyverse.tidyverse.org/>`__\  进行轻量数据的整理。

.. code-block:: R

    library(tidyverse)
    library(fs)


2.2 示例程序包：foofactors
-----------------------------

我们使用 devtools 中的各种功能从头开始构建一个小型的、作为示例的程序包，它具有在已发布的包中\
十分常见的功能：\ :sub:`存疑`\ 

- 满足特定需求的函数，例如与因子（ factors ）打交道的“助手”。\ :sub:`存疑`\ 
- 可以访问已完成的工作流程以进行安装、获得帮助以及检查包的基本质量。\ :sub:`优化表达`\ 
- 版本控制和开放的开发过程。
  - 在您的工作中，这是完全可选的，但我们建议这样做。您将看到 Git 和 GitHub 如何帮助我们展示程序包开发的所有中间阶段。
- 通过 \ `roxygen2 <https://cran.r-project.org/package=roxygen2>`__\  建立各个函数的文档 。
- 使用 \ `testthat <http://testthat.r-lib.org/>`__\  进行单元测试。
- 通过可执行文件整体了解软件包的文件`README.Rmd`。

我们称这个程序包包为 \ **foofactors**\ ，它将有几个处理因子（ factors ）的函数。请注意，\
这些功能非常简单，并且绝对不是本章的重点！有关正确处理因子（ factors ）的软件包，\
请参阅 \ `forcats <https://forcats.tidyverse.org/>`__\ 。

构建 foofactors 包本身不是我们的目标。它只是一个示例，用于演示使用 devtools 进行程序包开发的典型工作流程。


2.3 看看成品
------------

我们使用了 Git 版本控制系统追踪 foofactors 包的开发过程。这存粹是可选的，您当然可以不执行这个步骤。\
但是它有一个附加的好处：我们将其连接到 GitHub 上的远程储存库，这意味着您能够通过访问 GitHub 上的 foofactors 库\
来观看我们努力取得的光荣成果：https://github.com/jennybc/foofactors。通过\
检查 \ `commit history <https://github.com/jennybc/foofactors/commits/master>`__\ （尤其是\
版本差异），您能够清楚地看到其下列出的过程中每个步骤更改了什么。

\ *TODO: I think these diffs are extremely useful and would like to surface them better here.*\ 



2.4 ``create_package()``
---------------------------

调用 ``create_package()``，选择计算机一个目录，初始化新的程序包（如果有需要，还可以新建一个目录）。\
关于更多的信息，请参见 \ `5.1.3 <https://r-pkgs.org/workflows101.html#creating>`__\  节。

仔细选择创建新程序包的目录。它可以与其他 R 项目共同位于主目录下。但是，它不应该被嵌套在\
另一个 RStudio 项目、R 包或者是 Git 存储库中。它也不应该在 R 的程序包库中，因为这个库目录下\
包含有已经被构建和安装的程序包。将这里创建的源程序包转换为已安装程序包的过程，是 devtools 包可以\
促进完成的一部分工作。不要尝试为此做 devtools 的工作！\ :sub:`存疑`\ 关于更多的信息，\
请参见 \ `5.1.4 <https://r-pkgs.org/workflows101.html#where-source-package>`__\  节。

将您选择的路径作为参数传入 ``create_package()`` 中，如下所示：

.. code-block:: R

    create_package("~/path/to/foofactors")

我们必须在临时目录中工作，因为这本书是在云中非交互式构建的。\
在幕后，我们执行自己的 ``create_package()`` 命令，但如果我们的输出与你的输出略有不同，请不要感到惊讶。

.. code-block:: R

    #> ✔ Creating '/tmp/RtmpsJ87ir/foofactors/'
    #> ✔ Setting active project to '/tmp/RtmpsJ87ir/foofactors'
    #> ✔ Creating 'R/'
    #> ✔ Writing 'DESCRIPTION'
    #> Package: foofactors
    #> Title: What the Package Does (One Line, Title Case)
    #> Version: 0.0.0.9000
    #> Authors@R (parsed):
    #>     * First Last <first.last@example.com> [aut, cre] (<https://orcid.org/YOUR-ORCID-ID>)
    #> Description: What the package does (one paragraph).
    #> License: What license it uses
    #> Encoding: UTF-8
    #> LazyData: true
    #> ✔ Writing 'NAMESPACE'
    #> ✔ Writing 'foofactors.Rproj'
    #> ✔ Adding '.Rproj.user' to '.gitignore'
    #> ✔ Adding '^foofactors\\.Rproj$', '^\\.Rproj\\.user$' to '.Rbuildignore'
    #> ✔ Setting active project to '<no active project>'
    #> ✔ Setting active project to '/tmp/RtmpsJ87ir/foofactors'


如果您在 RStudio 中工作，您会发现自己进入了一个新的 RStudio 程序界面，\
它已经打开了新的 foofactors 包（或项目）目录。如果您处于某种原因需要手动执行这个操作，\
请进入该目录并双击 ``foofactors.Rproj``。RStudio 对于软件包做了特殊处理，您现在应该可以\
在 \ *Evironment*\ 和 \ *History*\ 所在的窗格中看到 \ *Build*\ 选项卡。

\ *TODO: good place for a screenshot.*\

在这个新目录里的内容是一个 R 包，也许还是个 RStudio Project？\
以下是文件清单（在本地，您可以查看 \ *Files*\  选项卡）：

.. code-block:: R

    #> # A tibble: 6 x 2
    #>   path             type     
    #>   <fs::path>       <fct>    
    #> 1 .Rbuildignore    file     
    #> 2 .gitignore       file     
    #> 3 DESCRIPTION      file     
    #> 4 NAMESPACE        file     
    #> 5 R                directory
    #> 6 foofactors.Rproj file

\

    .. |Logo| image:: ./Image/Chapter_1/rstudio.png
            :width: 220.6
            :height: 255.7
            :scale: 50

    |Logo| 
        
    在文件浏览器中，转到 \ *More > Show Hidden Files*\  来切换隐藏文件\
    （也称为 \ `dotfiles <https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory#Unix_and_Unix-like_environments>`__\ ）的可见性。\
    一些文件是始终可见的，但有时您可能会希望看到全部的文件。

- ``.Rbuildignore`` 列出了我们编写 R 包时需要的，但是从源代码构建 R 包时并不需要的文件。详情请见 \ `4.3.1 <https://r-pkgs.org/package-structure-state.html#rbuildignore>`__\ 。
- ``.Rproj.user``，如果有的话，它是 RStudio 内部使用的目录。
- ``.gitignore`` 为 Git 的使用做好准备。它将忽略一些由 R 或 RStudio 创建的标准的幕后文件。即使您不打算使用 Git，它也是没有妨害的。
- ``DESCRIPTION`` 提供了\ `有关您的程序包的元数据 <https://r-pkgs.org/description.html#description>`__\ 。我们很快将开始编写它。
- ``NAMESPACE`` 声明了程序包导出供外部使用的函数以及从其他程序包导入的外部函数。目前，它包含暂未起作用的用于占位的内容。（具体可见本书 \ `NAMESPACE <https://r-pkgs.org/namespace.html#namespace>`__\  一章）
- ``R/`` 目录是\ `程序包的“业务端” <https://r-pkgs.org/r.html#r>`__\ 。它很快将包含带有函数声明的 ``.R`` 文件。
- ``foofactors.Rproj`` 是使得该目录成为 RStudio 项目的文件。即使你不使用 RStudio，这个文件也是没有妨害的。如果您不想创建它，可以使用 ``create_package(..., rstudio = FALSE)``。详情请见 \ `5.2 <https://r-pkgs.org/workflows101.html#projects>`__\ 。



2.5 ``use_git()``
-----------------


    .. |bulb| image:: ./Image/Chapter_2/lightbulb.png
        :width: 94.4
        :height: 118.1
        :scale: 50
    
    |bulb|

    Git 或其他版本控制系统的使用是可选项，但是长期来看我们建议您使用。\
    我们将在 \ `16 <https://r-pkgs.org/git.html#git>`__\ 中解释其重要性。

``foofactors`` 目录是 R 源码包和 RStudio 项目。现在，我们使用 ``use_git()`` 让它也变成一个 Git 存储库。

.. code-block:: R

    use_git()  
    #> ✔ Initialising Git repo
    #> ✔ Adding '.Rhistory', '.RData' to '.gitignore'


在交互式会话中，系统将询问您是否要在此处提交这些文件，您应该接受这个提议。\
在 R 中，您不会看到这些，但是在幕后，我们会进行同样的操作。

.. code-block:: R

    #> [bdb30c7] 2019-09-10: Initial commit



有什么新内容吗？仅仅是创建了目录，该目录在大多数环境中都是隐藏的，包括 RStudio 文件浏览器。\
但是它的存在证明我们确实在这里初始化了 Git 存储库 ``.git``。

.. code-block:: R

    #> # A tibble: 1 x 2
    #>   path       type     
    #>   <fs::path> <fct>    
    #> 1 .git       directory

如果您使用的是 RStudio，它可能会请求在此项目中重新启动。您可以通过退出然后\
双击 ``foofactors.Rproj`` 重新启动来手动执行此操作。\
现在，除了程序包的开发支持外，您还可以在 \ *Git*\  选项卡中访问一个基础的 Git 客户端。\
\ *Git*\  选项卡与 \ *Environment/History/Build*\  在同一个窗格中。

\ *TODO: good place for a screenshot.*\ 

单击 \ *History*\  （时钟图标），如果您愿意，您将看到通过 ``use_git()`` 进行的初始提交：

.. code-block:: R

    #> [bdb30c7] 2019-09-10: Initial commit


\

    .. |Logo| image:: ./Image/Chapter_1/rstudio.png
        :width: 220.6
        :height: 255.7
        :scale: 50
    
    |Logo|

    只要您设置了 RStudio + Git 集成，RStudio 可以在任何项目中初始化 Git 存储库，\
    即使它不是 R 包项目。依次点击 \ *Tools > Version Control > Project Setup*\ ，\
    然后选择 \ *Version control system: Git*\ ，然后选择 \ *initialize a new git repository for this project*\ 。



2.6 编写第一个函数
---------------------

因子（ factors ）的很多操作都令人费解\ :sub:`意译`\ 。让我们看看当我们把两个因子（ factors ）连接起来的时候会发生什么。

.. code-block:: R

    (a <- factor(c("character", "hits", "your", "eyeballs")))
    #> [1] character hits      your      eyeballs 
    #> Levels: character eyeballs hits your
    (b <- factor(c("but", "integer", "where it", "counts")))
    #> [1] but      integer  where it counts  
    #> Levels: but counts integer where it
    c(a, b)
    #> [1] 1 3 4 2 1 3 4 2

嗯？许多人并没有预料到，将两个因子（factors）连接起来的结果是一个包含数字 1，2，3，4 的整数向量。\
如果我们将每个因子（ factors ）强制转换为字符，进行分类，然后重新转换为因子（ factors ）呢？

.. code-block:: R

    factor(c(as.character(a), as.character(b)))
    #> [1] character hits      your      eyeballs  but       integer   where it 
    #> [8] counts   
    #> Levels: but character counts eyeballs hits integer where it your

这似乎产生了更有意义的结果。让我们将这个操作放在名为 ``fbind()`` 的函数体中：

.. code-block:: R

    fbind <- function(a, b) {
        factor(c(as.character(a), as.character(b)))
    }

这本书不会教您如何在 R 中编写函数。要了解更多有关该知识的信息，请查阅 \ *R for Data Science*\  和 \ *Advanced R*\  的 \ `FUnctions Chapter <https://r4ds.had.co.nz/functions.html>`__\ 。


2.7 ``use_r()``
---------------

我们该在哪里定义 ``fbind()`` 函数？应该将它保存在程序包的 ``/R`` 子目录中的 ``.R`` 文件内。\
一个合理的开始是为程序包中的每个函数创建一个新的 ``.R`` 文件，并以功能的名字为它命名。\
当您添加更多的函数后，您可能会希望放宽这个要求，把相关的函数放在一起。我们将 ``fbind()`` 的函数定义放在 ``R/fbind.R`` 中。

函数 ``use_r()`` 将帮助我们在 ``R/`` 目录下创建和（或）打开脚本文件。当您在 ``.R`` 文件和关联测试的文件之间互相切换时，\
它确实在成熟的程序包中十分有用。但是，即使在这里，在 ``Untitled4`` 中工作时，它也可以避免您因为太投入而忘记了当前工作的目录。 \ :sub:`存疑`\ 

.. code-block:: R

    use_r("fbind")
    #> ● Edit 'R/fbind.R'

将函数 ``fbind()`` 的定义并且\ **仅仅是 ``fbind()`` 的定义**\ 放在 ``R/fbind.R`` 中并保存。\
文件 ``R/fbind.R`` 不应包含我们最近执行的其他任何顶级代码，例如因子 ``a`` 和 ``b``，``library(devtools)`` 或 ``use_git()`` 的定义。\
这预示了在从编写 R 脚本过渡到 R 包时需要进行的调整。程序包和脚本使用不同的机制来声明它们对其他包的依赖，\
不同之处还有存储示例或测试代码的方式。我们在第 \ `6 <https://r-pkgs.org/r.html#r>`__\  章中进一步探讨这一点。


2.8 ``load_all()``
------------------

我们应该怎样来测试 ``fbind()`` 函数 \ :sub:`drive一词何解`\  ？如果这是常规的 R 脚本，则可以使用 RStudio 将函数定义发送到 R 控制台，\
并且在全局工作空间中定义 ``fbind()``。或者，我们可以使用 ``source("R/fbind.R")`` 来调用该脚本。但是，在程序包开发中，\
devtools 提供了更为可靠的方法。有关更多信息，请参见 \ `5.4 <https://r-pkgs.org/workflows101.html#load-all>`__\  节。

调用 ``load_all()`` 使得函数 ``fbind()`` 可用于测试。

.. code-block:: R

    load_all()
    #> Loading foofactors

现在，调用 ``fbind(a, b)`` 看看它是怎样工作的。

.. code-block:: R

    fbind(a, b)
    #> [1] character hits      your      eyeballs  but       integer   where it 
    #> [8] counts   
    #> Levels: but character counts eyeballs hits integer where it your

我们可以注意到，虽然 ``fbind()`` 函数并不在全局工作空间中，但是 ``load_all()`` 使得我们可以使用该函数。

.. code-block:: R

    exists("fbind", where = ".GlobalEnv", inherits = FALSE)
    #> [1] FALSE

``load_all()`` 模拟了构建、安装和添加 foofactors 程序包的过程。当您的程序包积累了更多的函数时，有的导出了而有的没有，\
有的互相调用而有的从依赖的其他程序包中调用，``load_all()`` 相比于在全局工作空间中测试 \ :sub:`drive何解？`\ 函数定义，\
能够使您对于程序包的开发方式有更为准确的了解。同样的，``load_all()`` 允许比实际中构建、安装和添加程序包快得多的迭代。

到目前为止的内容：

- 我们已经编写了第一个函数 ``fbind()``，它能够将两个因子（ factors ）连接起来。
- 我们使用 ``load_all()`` 快捷地使得该函数可以用于交互使用，就好像我们已经构建并安装了 foofactors，并通过 ``library(foofactors)`` 添加到了工作环境中一样。


    .. |Logo| image:: ./Image/Chapter_1/rstudio.png
        :width: 220.6
        :height: 255.7
        :scale: 50
    
    |Logo|

    RStudio 提供了 ``load_all()`` 的快速调用。它位于 \ *Build*\  菜单和 \ *Build*\  窗格中，通过 \ *More > Load All*\  或者\
    键盘快捷键 Ctrl + Shift + L (WIndows & Linux) 或者 Cmd + Shift + L (MacOS)。


2.8.1 提交 ``fbind()`` 的更改
...............................

如果您使用了 Git，可以使用您喜欢的方法来提交新的 ``R/fbind.R`` 文件。我们在幕后也是这样做的。以下是提交前后相关的差异。

.. code-block:: R

    #> [b3fc569] 2019-09-10: Add fbind()
    #> diff --git a/R/fbind.R b/R/fbind.R
    #> new file mode 100644
    #> index 0000000..7b03d75
    #> --- /dev/null
    #> +++ b/R/fbind.R
    #> @@ -0,0 +1,3 @@
    #> +fbind <- function(a, b) {
    #> +  factor(c(as.character(a), as.character(b)))
    #> +}

从这一小节之后，我们每一步之后都会进行提交。\ `这些提交 <https://github.com/jennybc/foofactors/commits/master>`__\ 在公共储存库中都是可用的。



2.9 ``check()``
----------------

我们有经验可以证明 ``fbind()`` 是有效的。但是，我们如何确保 foofactors 包的其他所有可用的功能 \ :sub:`moving parts如何翻译`\  仍然有效呢？\
在添加很少的代码之后，仍然进行检查似乎很愚蠢，但养成经常检查的习惯是很好的。

``R CMD check`` 会在 shell 中执行，它是检查 R 包是否处于完整工作状态的黄金标准。在不离开 R 会话的情况下，``check()`` 是运行这个命令的便捷方法。

请注意，``check()`` 将生成相当多的输出，并针对交互式使用进行了优化。我们在这里截取了一部分，并仅仅展示摘要。本地运行 ``check()`` 的输出将有所不同。

.. code-block:: R

    check()

.. code-block:: R

    #> ── R CMD check results ───────────────────────── foofactors 0.0.0.9000 ────
    #> Duration: 6.6s
    #> 
    #> ❯ checking DESCRIPTION meta-information ... WARNING
    #>   Non-standard license specification:
    #>     What license it uses
    #>   Standardizable: FALSE
    #> 
    #> ❯ checking for missing documentation entries ... WARNING
    #>   Undocumented code objects:
    #>     ‘fbind’
    #>   All user-level objects in a package should have documentation entries.
    #>   See chapter ‘Writing R documentation files’ in the ‘Writing R
    #>   Extensions’ manual.
    #> 
    #> 0 errors ✔ | 2 warnings ✖ | 0 notes ✔

\ **请阅读 check 的输出内容！**\ 尽可能早并经常性的解决出现的问题。就像在 ``.R`` 和 ``.Rmd`` 文件上的增量开发一样,\
您进行全面检查以确保一切正常的间隔时间越长，查明并解决问题的难度也越大。

在这一步中，我们收到了 2 个警告（0 个错误，0 个注释）：

- ``Non-standard license specification``
- ``Undocumented code objects: 'fbind'``

我们将尽快解决这两个问题。


    .. |Logo| image:: ./Image/Chapter_1/rstudio.png
        :width: 220.6
        :height: 255.7
        :scale: 50
    
    |Logo|

    RStudio 提供了 ``check()`` 的快速调用。它位于 \ *Build*\  菜单和 \ *Build*\  窗格中，通过 \ *Check*\  或者\
    键盘快捷键 Ctrl + Shift + E (WIndows & Linux) 或者 Cmd + Shift + E (MacOS)。


2.10 编辑 ``DESCRIPTION``
----------------------------

